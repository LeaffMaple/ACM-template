[TOC]



## 数据结构

### 1.莫队.

```c++
	FOR(i,0,q-1){
		ll l,r;
		scanf("%lld%lld",&l,&r);
		que[i]={l,r,i};
	}
	sort(que,que+q,[&](array<ll,3>a,array<ll,3>b){
		if(a[0]/M!=b[0]/M)return a[0]/M<b[0]/M;
		return a[1]<b[1]; 
	});
	ll l=1,r=0;
	ll tmp=0;
	auto add=[&](ll x){
		tmp+=cnt[c[x]];
		cnt[c[x]]++;
	};
	auto del=[&](ll x){
		cnt[c[x]]--;
		tmp-=cnt[c[x]];
	};
	for(ll i=0;i<q;i++){
		while(l<que[i][0])del(l),l++;
		while(r<que[i][1])r++,add(r);
		while(l>que[i][0])l--,add(l);
		while(r>que[i][1])del(r),r--;
	}
```

### 带修莫队

```c++
//https://www.luogu.com.cn/problem/P1903
array<int,4>que[N];
array<int,2> chg[N];
int cnt[N],ans[N],c[N];
signed main(){IOS
	ll n,m,q;
	cin>>n>>q;
	FOR(i,1,n) cin>>c[i];
	int M = pow(n,0.666);
	int cntq = 0, cntr =0;
	while(q--) {
		char op; cin>>op;
		int l,r,t,p,col; 
		if(op=='Q') {
			cin>>l>>r;
			que[++cntq]={l,r,cntr,cntq};
		}
		else {
			cin>>p>>col;
			chg[++cntr]={p,col};
		}
	}
    
	sort(que+1,que+1+cntq,[&](array<int,4>a,array<int,4>b){
        if(a[2]/M != b[2]/M)return a[2] < b[2];
        if(a[0]/M != b[0]/M)return a[0] < b[0];
        return a[1] < b[1];
        // if(a[0]/M != b[0]/M)return a[0]/M < b[0]/M;
		// if(a[1]/M != b[1]/M)return a[1]/M < b[1]/M;
		// return a[2]<b[2];
	});

	ll l=1,r=0,t=0;
	ll res=0;
	auto add=[&](int x){
		if(!cnt[x])res++;
		cnt[x]++;	
	};
	auto del=[&](int x){
		cnt[x]--;
		if(!cnt[x])res--;
	};
	auto upd=[&](int x,int t){
		int pos = chg[t][0],col = chg[t][1];
		if(que[x][0]<=pos && pos<=que[x][1]){
			del(c[pos]);
			add(col);
		}
		swap(c[pos],chg[t][1]);//因为修改后的下一次操作一定相反
	};

	for(int i = 1; i <= cntq; i++){
		while(l<que[i][0]) del(c[l]), l++;
		while(r<que[i][1]) r++, add(c[r]);
		while(l>que[i][0]) l--, add(c[l]);
		while(r>que[i][1]) del(c[r]), r--;
		while(t<que[i][2]) t++, upd(i,t);
		while(t>que[i][2]) upd(i,t), t--;
		ans[que[i][3]] = res;
	}
	FOR(i,1,cntq)cout<<ans[i]<<endl;
	return 0;
}
```



### 2.并查集.

```c++
ll f[N],sz[N];
ll find(ll x){
    if(f[x]==x)return x;
    return f[x]=find(f[x]);
}
void merge(ll x,ll y){
    ll fx=find(x),fy=find(y);
    if(fx==fy)return ;
    f[fx]=fy;
    sz[fy]+=sz[fx];
}
```

### 3.倍增.

```c++
	FOR(j,1,20){
		for(ll i=1;i+(1<<j)-1<=n;i++){
			f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);
		}
	}
    for (int i = 1; i <= q; i++) {
         ll l, r;cin>>l>>r;
		int len=31-__builtin_clz(r-l+1);
		ans=max(f[l][len],f[r-(1<<len)+1][len]);
    }
```

### 4.二维树状数组.

```c++
void add(ll x,ll y,ll s){ 
	for(ll p=x;p<=N;p+=lowbit(p)){
		for(ll q=y;q<=N;q+=lowbit(q)){
			sum[p][q]+=s;
		}
	}
}
ll ask(ll x,ll y){ //查询[0,x]*[0,y]矩形的和
	ll t=0;
	for(ll p=x;p;p-=lowbit(p)){
		for(ll q=y;q;q-=lowbit(q)){
			t+=sum[p][q];
		}
	}
	return t;
}
```

### 5.树状数组二分.

```c++
template<typename T>
struct Fenwick{
    int n;
    vector<T> tr;

    Fenwick(int n) : n(n), tr(n + 1, 0){}

    int lowbit(int x){
        return x & -x;
    }

    void modify(int x, T c){
        for(int i = x; i <= n; i += lowbit(i)) tr[i] += c;
    }

    void modify(int l, int r, T c){
        modify(l, c);
        if (r + 1 <= n) modify(r + 1, -c);
    }

    T query(int x){
        T res = T();
        for(int i = x; i; i -= lowbit(i)) res += tr[i];
        return res;
    }

    T query(int l, int r){
        return query(r) - query(l - 1);
    }

    int find_first(T sum){//第一个=sum
        int ans = 0; T val = 0;
        for(int i = __lg(n); i >= 0; i--){
            if ((ans | (1 << i)) <= n && val + tr[ans | (1 << i)] < sum){
                ans |= 1 << i;
                val += tr[ans | (1 << i)];
            }
        }
        return ans + 1;
    }

    int find_last(T sum){//最后一个<=sum
        int ans = 0; T val = 0;
        for(int i = __lg(n); i >= 0; i--){
            if ((ans | (1 << i)) <= n && val + tr[ans | (1 << i)] <= sum){
                ans |= 1 << i;
                val += tr[ans | (1 << i)];
            }
        }
        return ans;
    }

};
using BIT = Fenwick<int>;
```

### 6.珂朵莉树.

```c++
struct node{
    ll l, r;
    mutable ll v; // 这里mutable要写不然可能会CE
    node(ll l, ll r, ll v) : l(l), r(r), v(v) {} // 构造函数
    bool operator<(const node &o) const { return l < o.l; } // 重载小于运算符
};
set<node> tree;
auto split(ll pos){// 若不支持C++14，auto须改为set<node>::iterator
    auto it = tree.lower_bound(node(pos, 0, 0)); // 寻找左端点大于等于pos的第一个节点
    // 若不支持C++11，auto须改为set<node>::iterator
    if (it != tree.end() && it->l == pos) // 如果已经存在以pos为左端点的节点，直接返回
        return it;
    it--; // 否则往前数一个节点
    ll l = it->l, r = it->r, v = it->v;
    tree.erase(it); // 删除该节点
    tree.insert(node(l, pos - 1, v)); // 插入<l,pos-1,v>和<pos,r,v>
    return tree.insert(node(pos, r, v)).first; // 返回以pos开头的那个节点的迭代器
                                               // insert默认返回值是一个pair，第一个成员是我们要的
}
void assign(ll l, ll r, ll v){
    auto end = split(r + 1), begin = split(l); // 顺序不能颠倒，否则可能RE
    tree.erase(begin, end); // 清除一系列节点
    tree.insert(node(l, r, v)); // 插入新的节点
}
void rev(ll l,ll r){
    auto end=split(r+1),begin=split(l);
    for(auto it=begin;it!=end;it++)it->v^=1;
}
ll query(){
    ll res=1e18+1;
    for(auto it=tree.begin();it!=tree.end();it++){
        if(!it->v)return it->l;
    }
    return res;
}

signed main(){IOS
    ll q;cin>>q;
    tree.insert({1,M,0});//插入初始区间
    while(q--){
        ll op,l,r;cin>>op>>l>>r;
        if(op==1){
            assign(l,r,1); //区间覆盖为1
        }else if(op==2){
            assign(l,r,0);//区间 覆盖为0
        }else {
            rev(l,r);//区间翻转
        }
        cout<<query()<<endl;
    }

    return 0;
}
```

### 7.dfs序求LCA.

```c++
//https://www.luogu.com.cn/blog/AlexWei/leng-men-ke-ji-dfs-xu-qiu-lca
vector<ll>g[N];
ll dep[N];
ll l[N],r[N],tot;
ll lg[N];
ll st[20][N];//维护区间深度最小值所在的dfs序的父亲
void dfs(ll u,ll fa){
	l[u]=++tot;st[0][l[u]]=fa;
	dep[u]=dep[fa]+1;
	for(auto v:g[u]){
		if(v==fa)continue;
		dfs(v,u);
	}
	r[u]=tot;
}
ll get(ll x,ll y){return dep[x] < dep[y] ? x : y;}
void init(ll n){
	FOR(i,2,N-5)lg[i]=lg[i>>1]+1;
	FOR(i,1,lg[n]){
		for(int j=1;j+(1<<i)-1<=n;j++){
			st[i][j]=get(st[i-1][j],st[i-1][j+(1<<i-1)]);
		}
	}
}
ll LCA(ll u,ll v){
	if(u==v)return u;
	if((u=l[u])>(v=l[v]))swap(u,v);
	ll d=lg[v-u++];//考虑一条链的情况，u++ 同时也不影响不在一条链上的时候。
	return get(st[d][u],st[d][v-(1<<d)+1]);
}

signed main(){IOS
	ll n,m,s;cin>>n>>m>>s;
	FOR(i,2,n){
		ll u,v;cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs(s,0);
	init(n);
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		cout<<LCA(u,v)<<endl;
	}
	return 0;
}
```

### 倍增求LCA

```c++
const int M=2e5+5;
ll fat[M][21],st[M][21],dep[M];
vector<pll>g[M];

void dfs(ll u,ll fa){
    for(int i=1;i<=20;i++){
        fat[u][i]=fat[fat[u][i-1]][i-1];
        st[u][i]=max(st[u][i-1],st[fat[u][i-1]][i-1]);
    }
    for(auto [v,w]:g[u]){
        if(v==fa)continue;
        fat[v][0]=u;dep[v]=dep[u]+1;st[v][0]=w;
        dfs(v,u);
    }
}
pll LCA(ll u,ll v){ //得到祖先和路径最值
    if(dep[u]<dep[v])swap(u,v);
    ll mx=0;
    ROF(i,20,0){
        if(dep[fat[u][i]]>=dep[v]){
        	mx=max(mx,st[u][i]);
        	u=fat[u][i];
		}
    }
    if(u==v)return {u,mx};
    ROF(i,20,0){
        if(fat[u][i]!=fat[v][i]){
            mx=max({mx,st[u][i],st[v][i]});
            u=fat[u][i],v=fat[v][i];
        }
    }
    mx=max({mx,st[u][0],st[v][0]});
    return {fat[u][0],mx};
}
```



### 8.主席树动态开店求区间k大和.

```c++
struct Node{
    int l, r;
    int cnt;
    int sum;
}tr[N << 5];
int n, m, idx , root[N], a[N], k, x;

void pushup(int u){
    tr[u].cnt = tr[tr[u].l].cnt + tr[tr[u].r].cnt;
    tr[u].sum = tr[tr[u].l].sum + tr[tr[u].r].sum;
}

void insert(int &u, int v, int l, int r, int x){
    u = ++ idx;
    tr[u] = tr[v];
    tr[u].cnt ++ ;
    tr[u].sum += x;
    if(l == r) return ;
    int mid = l + r >> 1;
    if(x <= mid) insert(tr[u].l, tr[v].l, l, mid, x);
    else insert(tr[u].r, tr[v].r, mid + 1, r, x);
    pushup(u);
}

int query(int p, int q, int l, int r, int k){
    if(l == r) return k*l;
    int cnt = tr[tr[q].r].cnt - tr[tr[p].r].cnt;
    int mid = l + r >> 1;
    if(k <= cnt) return query(tr[p].r, tr[q].r, mid + 1, r, k);
    if(k > cnt) return tr[tr[q].r].sum - tr[tr[p].r].sum + query(tr[p].l, tr[q].l, l, mid, k - cnt);
}

int main(){
    cin >> n >> m >> k >> x;
    for(int i = 1 ; i <= n ; i ++ ){
        cin >> a[i];
        insert(root[i], root[i - 1], 0, INF, a[i]);//INF 是线段树的右端点
    }
    for(int i = 1 ; i <= m ; i ++ ){
        int l, r;
        cin >> l >> r;
        cout << (query(root[l - 1], root[r], 0, INF, k) >= x ? "Y" : "N") << endl;
    }
    return 0;
}
```

### 主席树求区间第k小

```c++
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;
const int maxn = 1e5;  // 数据范围
int tot, n, m;
int sum[(maxn << 5) + 10], rt[maxn + 10], ls[(maxn << 5) + 10],
    rs[(maxn << 5) + 10];
int a[maxn + 10], ind[maxn + 10], len;

inline int getid(const int &val) {  // 离散化
  return lower_bound(ind + 1, ind + len + 1, val) - ind;
}

int build(int l, int r) {  // 建树
  int root = ++tot;
  if (l == r) return root;
  int mid = l + r >> 1;
  ls[root] = build(l, mid);
  rs[root] = build(mid + 1, r);
  return root;  // 返回该子树的根节点
}

int update(int k, int l, int r, int root) {  // 插入操作
  int dir = ++tot;
  ls[dir] = ls[root], rs[dir] = rs[root], sum[dir] = sum[root] + 1;
  if (l == r) return dir;
  int mid = l + r >> 1;
  if (k <= mid)
    ls[dir] = update(k, l, mid, ls[dir]);
  else
    rs[dir] = update(k, mid + 1, r, rs[dir]);
  return dir;
}

int query(int u, int v, int l, int r, int k) {  // 查询操作
  int mid = l + r >> 1,
      x = sum[ls[v]] - sum[ls[u]];  // 通过区间减法得到左儿子中所存储的数值个数
  if (l == r) return l;
  if (k <= x)  // 若 k 小于等于 x ，则说明第 k 小的数字存储在在左儿子中
    return query(ls[u], ls[v], l, mid, k);
  else  // 否则说明在右儿子中
    return query(rs[u], rs[v], mid + 1, r, k - x);
}

inline void init() {
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= n; ++i) scanf("%d", a + i);
  memcpy(ind, a, sizeof ind);
  sort(ind + 1, ind + n + 1);
  len = unique(ind + 1, ind + n + 1) - ind - 1;
  rt[0] = build(1, len);
  for (int i = 1; i <= n; ++i) rt[i] = update(getid(a[i]), 1, len, rt[i - 1]);
}

int l, r, k;

inline void work() {
  while (m--) {
    scanf("%d%d%d", &l, &r, &k);
    printf("%d\n", ind[query(rt[l - 1], rt[r], 1, len, k)]);  // 回答询问
  }
}

int main() {
  init();
  work();
  return 0;
}
```



### 9.树链刨分（例题）.

```c++
ll a[N],vis[N];
vector<vector<ll>>G;//G.resize(n, vector<ll>(m, 0)); ????n?m????
ll dep[N],siz[N],hs[N],top[N],idx[N],fat[N],l[N],r[N];
ll n,tot,q,m;
vector<ll>g[N];
const int NM=3e5;
struct info{
    ll lc,rc,seg;
};
info operator + (const info &l,const info &r){
    info a;
    a.lc=l.lc;a.rc=r.rc;
    a.seg=l.seg+r.seg+(l.rc!=r.lc);
    return a;
}
struct node{
    info val;
    ll t;
}seg[4*NM];
void settag(ll id,ll t){
    seg[id].val={t,t,0};
    seg[id].t=t;
}
void pushdown(int id) {
	if (seg[id].t != 0) {
		settag(id * 2, seg[id].t);
		settag(id * 2 + 1, seg[id].t);
		seg[id].t = 0;
	}
}
void update(ll id){
    seg[id].val=seg[id*2].val+seg[id*2+1].val;
}
void build(ll id,ll l,ll r){
    if(l==r)seg[id].val={a[idx[l]],a[idx[l]],0};
    else {
        ll mid=(l+r)/2;
        build(id*2,l,mid);
        build(id*2+1,mid+1,r);
        update(id);
    }
}
void modifty(ll id,ll l,ll r,ll ql,ll qr,ll t){
    if(l==ql&&r==qr){
        settag(id,t);
        return ;
    }
    ll mid=(l+r)/2;
    pushdown(id);
    if(qr<=mid)modifty(id*2,l,mid,ql,qr,t);
    else if(ql>mid)modifty(id*2+1,mid+1,r,ql,qr,t);
    else {
        modifty(id*2,l,mid,ql,mid,t);
        modifty(id*2+1,mid+1,r,mid+1,qr,t);
    }
    update(id);
}
info query(ll id,ll l,ll r,ll ql,ll qr){
    if(l==ql&&r==qr)return seg[id].val;
    ll mid=(l+r)/2;
    pushdown(id);
    if(qr<=mid)return query(id*2,l,mid,ql,qr);
    else if(ql>mid)return query(id*2+1,mid+1,r,ql,qr);
    else {
        return query(id*2,l,mid,ql,mid)+
               query(id*2+1,mid+1,r,mid+1,qr);
    }
}
void dfs1(ll u,ll fa){
    siz[u]=1;
    dep[u]=dep[fa]+1;
    hs[u]=-1;
    fat[u]=fa;
    for(auto v:g[u]){
        if(v==fa)continue;
        dfs1(v,u);
        if(siz[v]>siz[hs[u]]||hs[u]==-1)hs[u]=v;
        siz[u]+=siz[v];
    }
}
void dfs2(ll u,ll t){
    top[u]=t;
    l[u]=++tot;
    idx[tot]=u;
    if(hs[u]!=-1)dfs2(hs[u],t);
    for(auto v:g[u]){
        if(v==hs[u]||v==fat[u])continue;
        dfs2(v,v);
    }
    r[u]=tot;
}
ll que(ll u,ll v){
    info ansu{0,0,-1},ansv{0,0,-1};
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]]){
            ansv=query(1,1,n,l[top[v]],l[v])+ansv;
            v=fat[top[v]];
        }
        else {
            ansu=query(1,1,n,l[top[u]],l[u])+ansu;
            u=fat[top[u]];
        }
    }
    if(dep[u]<=dep[v])ansv=query(1,1,n,l[u],l[v])+ansv;
    else ansu=query(1,1,n,l[v],l[u])+ansu;
    return ansu.seg+ansv.seg+(ansu.lc!=ansv.lc)+1;
}
void modfy(ll u,ll v,ll c){
    while(top[u]!=top[v]){
        if(dep[top[u]]<=dep[top[v]]){
            modifty(1,1,n,l[top[v]],l[v],c);
            v=fat[top[v]];
        }
        else {
            modifty(1,1,n,l[top[u]],l[u],c);
            u=fat[top[u]];
        }
    }
    if(dep[u]<=dep[v])modifty(1,1,n,l[u],l[v],c);
    else modifty(1,1,n,l[v],l[u],c);
}

signed main(){
    scanf("%lld%lld", &n,&q);
    FOR(i,1,n)scanf("%lld",&a[i]);
    FOR(i,1,n-1){
        ll u,v;
    	scanf("%lld%lld", &u, &v);
        g[u].push_back(v);
        g[v].push_back(u); 
    }
    dfs1(1,0);
    dfs2(1,1);
    build(1,1,n);
    FOR(i,1,q) {
    	char op[10];
		int u, v;
		scanf("%s%lld%lld", op, &u, &v);
		if (op[0] == 'C') {
			ll c;
			scanf("%lld",&c);
			modfy(u, v, c); //u到v全染成c
		} else {
			printf("%lld\n", que(u, v));//u到v路径上的颜色数量
		}
	}
}
//http://oj.daimayuan.top/course/15/problem/820

```

### 10.笛卡尔树.

```c++
ll n,root;
ll l[N],r[N];
ll s[N];
void build(){ //建笛卡尔树
	ll head=1,top=0;
	FOR(i,1,n){
		ll last=0;
		while(top&&a[s[top]]>a[i]){
			last=s[top];
			top--;
		}
		if(top)r[s[top]]=i;
		l[i]=last;
		s[++top]=i;
	}
	root=s[1];
}
```

### 11.线段树合并.

```c++
const int N=4e6+5;
const int mod=1e9+7;
/*-----------------------------------------------------------------------------------------------*/
ll R[N],P[N],cnt,len;
ll f[N];
ll find(ll x){
    if(f[x]==x)return x;
    return f[x]=find(f[x]);
}
struct node{
	ll mx,sum;
	ll ls,rs;
}seg[N];
void update(ll x){
	ll ls=seg[x].ls,rs=seg[x].rs;
	seg[x].sum=seg[ls].sum+seg[rs].sum;
}
void add(ll pos,ll val,ll &p,ll l=1,ll r=len){
	if(!p)p=++cnt;
	if(l==r)return void(seg[p].sum+=val);
	ll mid=(l+r)/2;
	if(pos<=mid)add(pos,val,seg[p].ls,l,mid);
	else add(pos,val,seg[p].rs,mid+1,r);
	update(p);
}
ll merg(ll p,ll q,ll l=1,ll r=len){
	if(!p||!q)return p+q;
	if(l==r){
		// seg[p].sum+=seg[q].sum;
		// return p;
		return seg[p].sum+=seg[q].sum,p;
	}
	ll mid=(l+r)/2;
	seg[p].ls=merg(seg[p].ls,seg[q].ls,l,mid);
	seg[p].rs=merg(seg[p].rs,seg[q].rs,mid+1,r);
	update(p);
	return p;
}
ll kth(ll k,ll p,ll l=1,ll r=len){
	if(l==r)return seg[p].sum>=k?l:0;
	ll mid=(l+r)/2;
	if(seg[seg[p].ls].sum>=k)return kth(k,seg[p].ls,l,mid);
	else return kth(k-seg[seg[p].ls].sum,seg[p].rs,mid+1,r);
}

signed main(){IOS
	ll n,m;cin>>n>>m;
	len=n;
	FOR(i,1,n){
		ll x;cin>>x;
		P[x]=i,f[i]=i;
		add(x,1,R[i]);
	}	
	FOR(i,1,m){
		ll u,v;cin>>u>>v;
		ll fx=find(u),fy=find(v);
		f[fy]=fx;
		merg(R[fx],R[fy]);
	}
	P[0]=-1;
	ll q;cin>>q;
	while(q--){
		char op;
		ll x,y;
		cin>>op>>x>>y;
		if(op=='Q'){
			ll fx=find(x);
			ll pos=kth(y,R[fx]);
			cout<<P[pos]<<endl;
		}else {
			ll fx=find(x),fy=find(y);
			f[fy]=fx;
			R[fy]=merg(R[fx],R[fy]);
		}
	}
	return 0;
}
// https://www.luogu.com.cn/problem/P3224
// 题意：  初始给一个图 每个节点有权值 
// q次询问  1:添一条边
//         2: 查询与x相连的点中第k小的

```





### 12.动态开点线段树.

```c++
struct info{
    ll sum,val,cnt;
    ll l,r;
};
info seg[N*5];
ll root,id;
bool make(ll &x,ll l,ll r){
    if(x)return 0;
    x=++id;
    seg[x]={0,0,0,0,0};
    return 1;
}
void update(ll id){
    seg[id].cnt=seg[ls].cnt+seg[rs].cnt;
    seg[id].sum=seg[ls].sum+seg[rs].sum;
}
void change(ll &id,ll l,ll r,ll pos,ll w){
    make(id,l,r);
    if(l==r){
        seg[id].cnt+=w;
        seg[id].sum+=w*pos;
        return ;
    }
    if(pos<=mid)change(ls,l,mid,pos,w);
    else change(rs,mid+1,r,pos,w);
    update(id);
}
ll query(ll &id,ll l,ll r,ll k){
    if(!id)return 0;//区间都为0就不开点继续查了 省时间
    make(id,l,r);
    if(seg[id].cnt<k)return -1;
    if(l==r){
        return k*l;
    }
    if(seg[rs].cnt>=k)return query(rs,mid+1,r,k);
    return seg[rs].sum+query(ls,l,mid,k-seg[rs].cnt);
}
```



### 13.虚树

```c++
//https://www.luogu.com.cn/problem/P2495
vector<pll>g[N];
ll dep[N],mi[N];
ll l[N],tot;
ll lg[N];
ll st[20][N];//维护区间深度最小值所在的dfs序的父亲
ll is[N],s[N],t;
vector<ll>e[N];

bool cmp(ll x,ll y){
    return l[x]<l[y];
}
void push(ll x){//建虚树
    if(t==1){s[++t]=x;return ;}
    ll lca=LCA(x,s[t]);
    if(lca==s[t])return ;
    while(t>1&&l[s[t-1]]>=l[lca])e[s[t-1]].push_back(s[t--]);
    if(s[t]!=lca)e[lca].push_back(s[t]),s[t]=lca;
    s[++t]=x;
}
ll dp(ll u){//dp部分
    if(e[u].empty())return mi[u];
    ll tmp=0;
    for(auto v:e[u]){
        tmp+=dp(v);
    }
    e[u].clear();
    return min(mi[u],tmp);
}

signed main(){IOS
	ll n;cin>>n;
	FOR(i,2,n){
		ll u,v,w;cin>>u>>v>>w;
		g[u].push_back({v,w});
		g[v].push_back({u,w});
	}
    mi[1]=1e18;
	dfs(1,0);
	init(n);
	ll T;cin>>T;
    while(T--){
        ll m;cin>>m;
        FOR(i,1,m)cin>>is[i];
        sort(is+1,is+1+m,cmp);
        s[t=1]=1;
        FOR(i,1,m)push(is[i]);
        while(t>0)e[s[t-1]].push_back(s[t--]);
        cout<<dp(1)<<endl;
    }

	return 0;
}
```

### 14.01-tire.

```c++
ll tr[N][2],sum[N];
ll tot=1;
void insert(ll x,ll w){//w=1是插入x  w=-1是删掉x
    ll k=1;
    ROF(i,31,0){
        bool f=x>>i&1;
        if(!tr[k][f])tr[k][f]=++tot;
        k=tr[k][f];
        sum[k]+=w;
    }
}
ll query(ll x,ll l){//异或p < l
    ll k=1,res=0;
    ROF(i,31,0){
        bool f=x>>i&1,g=l>>i&1;
        if(g)res+=sum[tr[k][f]],k=tr[k][f^1];
        else k=tr[k][f];
    }
    return res;
}
signed main(){IOS
    ll q;cin>>q;
    while(q--){
        ll op,p,l,r;cin>>op;
        if(op==3){//多少个数^p < l 
            cin>>p>>l;
            cout<<query(p,l)<<endl;
        }else {
            cin>>p;
            insert(p,op==1?1:-1);
        }
    }
    return 0;
}
```

### 15.线段树分裂

![image-20230525023802858](C:\Users\leaf_maple\AppData\Roaming\Typora\typora-user-images\image-20230525023802858.png)

```c++
//https://www.luogu.com.cn/problem/P5494
#define ls(x) seg[x].l
#define rs(x) seg[x].r
#define lson(x) ls(x),l,mid
#define rson(x) rs(x),mid+1,r
/*-----------------------------------------------------------------------------------------------*/
int a[N],rt[N],tot;
int ctd;
int del[N];
struct node{
	int l, r;
	ll cnt;
}seg[N<<1];

int merge(int p,int q){
	if(!p||!q)return p+q;
	seg[p].cnt+=seg[q].cnt;
	seg[p].l=merge(seg[p].l,seg[q].l);
	seg[p].r=merge(seg[p].r,seg[q].r);
	seg[q]={0,0,0};
	del[++ctd]=q;//将删掉的点存起来，还能重复用，节省空间。
	return p;
}

void split(int p,int &q,ll k){
	if(!p)return ;
	seg[q]={0,0,0};
	q=ctd?del[ctd--]:++tot;
	ll lc=seg[ls(p)].cnt;
	if(lc<k)split(rs(p),rs(q),k-lc);
	else swap(rs(p),rs(q));
	if(lc>k)split(ls(p),ls(q),k);
	seg[q].cnt=seg[p].cnt-k;
	seg[p].cnt=k;
}

void change(int &id,int l,int r,int pos,ll w){
	if(!id)id=ctd?del[ctd--]:++tot,seg[id]={0,0,0};
	seg[id].cnt+=w;
	if(l==r)return ;
	ll mid=l+r>>1;
	if(pos<=mid)change(lson(id),pos,w);
	else change(rson(id),pos,w);
}	

ll query(int &id,int l,int r,int ql,int qr){
	if(ql<=l&&qr>=r)return seg[id].cnt;
	ll mid=l+r>>1;
	ll res=0;
	if(ql<=mid)res+=query(lson(id),ql,qr);
	if(qr>mid)res+=query(rson(id),ql,qr);
	return res;
}

ll kth(int id,int l,int r,int k){
	if(l==r)return l;
	ll mid=l+r>>1;
	if(seg[ls(id)].cnt>=k)return kth(lson(id),k);
	else return kth(rson(id),k-seg[ls(id)].cnt);
}

signed main(){IOS
	ll n,m; cin>>n>>m;
	for(int i=1; i<=n; i++){
		ll x;cin>>x;
		change(rt[1],1,n,i,x);
	}
	int ct=1;
	while(m--){
		int op,p,x,y,t,q;ll k;cin>>op;
		if(op==0){
			cin>>p>>x>>y;
			ll k1=query(rt[p],1,n,1,y);
			ll k2=query(rt[p],1,n,x,y);
			int tmp=0;
			//[1,n]-> [1,x-1] [x,n] -> [1,x-1] [x,y] [y+1,n] -> [x,y] [1,n]
			split(rt[p],rt[++ct],k1-k2);//前k1-k2个点留下,后面所以点进++tot
			split(rt[ct],tmp,k2);//前k2个点就下，剩下的和p合并
			rt[p]=merge(rt[p],tmp);
		}else if(op==1){
			cin>>p>>t;
			rt[p]=merge(rt[p],rt[t]);
		}else if(op==2){
			cin>>p>>q>>x;
			change(rt[p],1,n,x,q);
		}else if(op==3){
			cin>>p>>x>>y;
			cout<<query(rt[p],1,n,x,y)<<endl;

		}else {
			cin>>p>>k;
			if(seg[rt[p]].cnt<k){ cout<<-1<<endl; continue;}
			cout<<kth(rt[p],1,n,k)<<endl;
		}
	}

	return 0;
}
```

### 16.线段树历史和

![image-20230819142134013](C:\Users\leaf_maple\AppData\Roaming\Typora\typora-user-images\image-20230819142134013.png)

```c++
//https://codeforces.com/contest/1824/problem/D
#define ls id<<1
#define rs id<<1|1
#define lson ls,l,mid
#define rson rs,mid+1,r

int a[N],pos[N];

struct Tag{
    ll add,_add;//和标记   历史和标记
    int time;
    void merge(Tag tmp){//下传 tag
        _add += (add*tmp.time + tmp._add)%mod;
        add += tmp.add;
        time += tmp.time;
		_add%=mod; add%=mod; time%=mod;
	}
};
struct node {
    ll val,hval;//区间和  历史区间和
    Tag t;
    void update(int len,Tag tmp){ //下传节点
        t.merge(tmp);
        hval += val * tmp.time + tmp._add * len;
        val += tmp.add * len;
		hval%=mod;
		val%=mod;
    }
}seg[N<<2];

void pushdown(int id,int l,int r,int mid){
    seg[ls].update(mid-l+1,seg[id].t);
    seg[rs].update(r-mid,seg[id].t);
    seg[id].t={0,0,0};
}

void modify(int id,int l,int r,int ql,int qr,Tag t){
    if(ql<=l&&r<=qr){
        seg[id].update(r-l+1,t);
        return ;
    }
    int mid=l+r>>1;
    pushdown(id,l,r,mid);
    if(ql<=mid) modify(lson,ql,qr,t);
    if(qr>mid) modify(rson,ql,qr,t);
    seg[id].hval=seg[ls].hval+seg[rs].hval;
    seg[id].val=seg[ls].val+seg[rs].val;
}
ll query(int id,int l,int r,int ql,int qr){
    if(ql<=l&&r<=qr){
        return seg[id].hval;
    }
    int mid = l+r>>1;
    pushdown(id,l,r,mid);
    ll res = 0;
    if(ql<=mid)res += query(lson,ql,qr), res%=mod;
    if(qr>mid)res += query(rson,ql,qr), res%=mod;
    return res;
}
ll ans[N];
array<int,3>que[N];
signed main(){IOS
    int n,q;
    cin>>n>>q;
    FOR(i,1,q){
		int op,l,r,w; cin>>op>>l>>r;
		if(op==0){
			cin>>w;
			modify(1,1,n,l,r,{w,0,0});
		} 
		modify(1,1,n,1,n,{0,0,1});
		if(op==1)cout<<query(1,1,n,l,r)<<endl;
    }
    return 0;
}
```

### $17.cdq$分治

![image-20230819145427176](C:\Users\leaf_maple\AppData\Roaming\Typora\typora-user-images\image-20230819145427176.png)

```c++
//http://oj.daimayuan.top/course/30/problem/1293
ll sum[N], lim, ans[N];
void add(ll x,ll y){for(;x<=lim;x+=(-x&x)){sum[x]+=y;}}
ll ask(ll x,ll y=0){for(;x;x-=(-x&x)){y+=sum[x];}return y;}

array<int,5>a[N], tmp[N];
void solve(int l, int r){
	if(l==r)return ;
	int mid = l+r>>1;
	solve(l, mid); solve(mid+1, r);
	int i=l, j=mid+1, tot=0;
	while(i<=mid || j<=r){
		if(j>r || (i<=mid && a[i][1]<=a[j][1])){
			add(a[i][2],a[i][3]);
			tmp[++tot]=a[i++];
		}else {
			a[j][4] += ask(a[j][2]);
			tmp[++tot]=a[j++];
		}
	}
	for(int i=l; i<=mid; i++)add(a[i][2], -a[i][3]);
	for(int i=1; i<=tot; i++)a[l+i-1]=tmp[i];

}

signed main(){IOS
	int n; cin>>n>>lim;
	for(int i=1; i<=n; i++){
		cin>>a[i][0]>>a[i][1]>>a[i][2];
		a[i][3]=1;
	}
	sort(a+1,a+1+n);
	int t=0;
	for(int i=1; i<=n; i++){
		if(t!=0 && a[i][0]==a[t][0] && a[i][1]==a[t][1] && a[i][2]==a[t][2])a[t][3]++;
		else a[++t]=a[i];
	}
	solve(1,t);
	for(int i=1; i<=t; i++)ans[a[i][3]+a[i][4]-1]+=a[i][3];
	for(int i=0; i<n; i++)cout<<ans[i]<<endl;

	return 0;
}
```

18.点分治

```c++
//http://oj.daimayuan.top/course/30/problem/1283
//给你一棵树，边带权，统计树上距离不超过 k的点对数。
vector<pair<int,int>>g[N];
bool del[N];
int K, ans;
int mxs[N],sz[N];

void solve(int u, int siz){
    int root=-1,ms=siz+1;
    function<void(int,int)> dfs1 = [&](int u,int fa){//找到重心
        sz[u] = 1; mxs[u] = 0;
        for(auto [v,w]:g[u]) if(v!=fa && !del[v]){
            dfs1(v, u);
            sz[u] += sz[v];
            mxs[u] = max(mxs[u], sz[v]);
        }
        mxs[u] = max(mxs[u], siz-sz[u]);
        if(mxs[u] < ms) ms = mxs[u], root = u;
    };  
    dfs1(u, -1);
    vector<int>d1,d2;
    d1.push_back(0);

    auto cal=[&](vector<int> &d){
        sort(d.begin(), d.end());
        int r = d.size()-1;
        int res = 0;
        for(int i=0; i<d.size(); i++){
            while(d[r]+d[i]>K&&r>=0) r--;
            if(i<r) res += r-i;
        }
        return res;
    };

    function<void(int,int,int)> dfs2 = [&](int u, int fa, int dep){
        sz[u] = 1;
        d2.push_back(dep);
        d1.push_back(dep);
        for(auto [v,w]:g[u]) if(v!=fa && !del[v]){
            dfs2(v, u, dep + w);
            sz[u]+=sz[v];
        }
    };
    for(auto [v,w]:g[root]) if(!del[v]){
        d2.clear();
        dfs2(v,root,w);
        ans -= cal(d2);
    }
    ans += cal(d1);
    del[root] = 1;
    for(auto [v,w]:g[root]) if(!del[v]){
        solve(v,sz[v]);
    }   
}

signed main(){IOS
    int n; cin>>n;
    for(int i=1; i<n; i++){
        int u,v,w; cin>>u>>v>>w;
        g[u].push_back({v,w});
        g[v].push_back({u,w});
    }
    cin>>K;
    solve(1,n);
    cout<<ans<<endl;
    return 0;
}
```



## 图论

### 1.最大流.

```c++
const int V=1010;
const  int E=101000;
struct Flow{
    int s,t,vtot;
    int head[V],etot;
    int cur[V],dis[V];
    struct edge{
        int v,nxt;
        ll f;//流量
    }e[E*2];
    void add(int u,int v,ll w1,ll w2=0){
        e[etot]={v,head[u],w1};head[u]=etot++;
        e[etot]={u,head[v],w2};head[v]=etot++;
    }
    bool bfs(){
        FOR(i,1,vtot)dis[i]=0,cur[i]=head[i];
        queue<int>q;
        q.push(s);dis[s]=1;
        while(!q.empty()){
            int u=q.front();q.pop();
            for(int i=head[u];~i;i=e[i].nxt){
                int v=e[i].v;
                if(e[i].f&&!dis[v]){
                    dis[v]=dis[u]+1;
                    if(v==t)return 1;
                    q.push(v);
                }
            }
        }
        return 0;
    }   

    ll dfs(int u,ll m){//m是当前流量
        if(u==t)return m;
        ll flow=0;
        for(int i=cur[u];~i;cur[u]=i=e[i].nxt)
            if(e[i].f&&dis[e[i].v]==dis[u]+1){
                ll f=dfs(e[i].v,min(m,e[i].f));
                e[i].f-=f;
                e[i^1].f+=f;
                m-=f;flow+=f;
                if(!m)break;
            }
        if(!flow)dis[u]=-1;
        return flow;   
    }   
    ll dinic(){
        ll flow=0;
        while(bfs())flow+=dfs(s,INT64_MAX);
        return flow;
    }
    void init(int s_,int t_,int vtot_){
        s=s_;t=t_;vtot=vtot_;etot=0;
        FOR(i,1,vtot)head[i]=-1;
    }
}F;
```

### 2.边双联通分量.

```c++
vector<pll>g[N];
ll dfn[N],low[N];
ll tot,top,cnt;
ll st[N],ins[N];
ll bel[N];//点在的变双 编号
vector<ll>bridge;//桥
vector<ll>ans[N];
void tarjan(ll u,ll fa){
    low[u]=dfn[u]=++tot;
    ins[u]=1;
    st[++top]=u;
    for(auto to:g[u]){
		ll v=to.first,id=to.second;
        if(!dfn[v]){
            tarjan(v,id);
            low[u]=min(low[u],low[v]); 
            if (dfn[v] == low[v]) bridge.push_back(id+1); //要不要+1？
        }else if(id!=fa){//返祖边不能是父节点
            low[u]=min(low[u],dfn[v]);
        }
    }
	if (dfn[u] == low[u]) {
		++cnt;
		while (1) {
			int v = st[top];
			ans[cnt].push_back(v);
			ins[v] = false;
			bel[v] = cnt;
			top--;
			if (v == u) break;
		}
	}
}
signed main(){IOS
	ll n,m;cin>>n>>m;
	FOR(i,1,m){
		ll u,v;cin>>u>>v;
		if(u==v)continue;
		if(u>v)swap(u,v);
		g[u].push_back({v,i});
		g[v].push_back({u,i});
	}
	FOR(i,1,n)
		if(!dfn[i])tarjan(i,0);

    cout<<cnt<<endl;
	FOR(i,1,cnt){
		cout<<ans[i].size()<<' ';
		for(auto v:ans[i])cout<<v<<' ';
		cout<<endl;
	}
	return 0;
}
```

### 3.点双连通分量.

```c++
ll dfn[N],low[N],st[N];
ll tot,top,num;
vector<ll>g[N];
vector<ll>ans;
vector<ll>dcc[N];//点双
void tarjan(ll u,ll fa){
    low[u]=dfn[u]=++tot;
    st[++top]=u;
    if(u==fa&&g[u].size()==0){ //判孤点
        dcc[++num].push_back(u);
        return ;
    }
    for(auto v:g[u]){
        if(!dfn[v]){
            tarjan(v,u);
            low[u]=min(low[u],low[v]); 
            if(low[v]>=dfn[u]){
                ++num;
                while(st[top+1]!=v)dcc[num].push_back(st[top--]);
                dcc[num].push_back(u);
            }
        }else if(v!=fa)
            low[u]=min(low[u],dfn[v]);
    }
}

signed main(){IOS
    ll n,m;cin>>n>>m;
    FOR(i,1,m){
        ll u,v;cin>>u>>v; //判自环
        if(u==v)continue;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    FOR(i,1,n){
        if(dfn[i])continue;
        top=0;
        tarjan(i,i);
    }
    cout<<num<<endl;
    FOR(i,1,num){
        cout<<dcc[i].size()<<' ';
        for(auto v:dcc[i])cout<<v<<' ';
        cout<<endl;
    }
    return 0;
}
```

### 4.割点.

```c++
vector<ll>g[N];
ll dfn[N],low[N];
ll tot;
vector<ll>ans;
void tarjan(ll u,ll fa){
    low[u]=dfn[u]=++tot;
    ll cnt=0;//删当前点可以增加的个数
    for(auto v:g[u]){
        if(!dfn[v]){
            tarjan(v,u);
            low[u]=min(low[u],low[v]); 
            if(low[v]>=dfn[u])cnt++;
        }else if(v!=fa){//割点要注意返祖边不能是父节点
            low[u]=min(low[u],dfn[v]);
        }
    }
    if(cnt>=1+(u==fa)){//不是根或者知识删掉当前点能增加2个
        ans.push_back(u);
    }
}

signed main(){IOS
    ll n,m;cin>>n>>m;
    FOR(i,1,m){
        ll u,v;cin>>u>>v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    FOR(i,1,n){
        if(dfn[i])continue;
        tarjan(i,i);
    }
    cout<<ans.size()<<endl;
    sort(ans.begin(),ans.end());
    for(auto v:ans)cout<<v<<' ';
    cout<<endl;

    return 0;
}
```

### 5.缩点.

```c++
vector<ll>g[N];
ll dfn[N],low[N],st[N],a[N];
ll tot,top;
int cnt;
int scc[N];//每个点所在的连通块
ll val[N];//每个连通块的权值和
ll vis[N];
vector<ll>e[N];
void tarjan(ll u,ll fa){
    low[u]=dfn[u]=++tot;
    st[++top]=u;
    vis[u]=1;
    for(auto v:g[u]){
        if(!dfn[v]){
            tarjan(v,u);
            low[u]=min(low[u],low[v]); 
        }else if(vis[v])low[u]=min(low[u],dfn[v]);
    }
    if(low[u]==dfn[u]){
        cnt++;
        int node;
        do {//u以及后面的全部出栈，缩为一个点
            node=st[top];
            vis[node]=0;
            scc[node]=cnt;
            top--;
        }while (node!=u);
    }
}

ll du[N],f[N];
ll topsort(){
    ll ans=0;
    queue<ll>q;
    FOR(i,1,cnt){
        if(!du[i]){
            q.push(i);
            f[i]=val[i];
        }
    }
    while(!q.empty()){
        ll u=q.front();q.pop();
        for(auto v:e[u]){
            f[v]=max(f[v],f[u]+val[v]);
            du[v]--;
            if(!du[v])q.push(v);
        }
        ans=max(ans,f[u]);
    }
    return ans;
}

signed main(){IOS
    ll n,m;cin>>n>>m;
    FOR(i,1,n)cin>>a[i];
    vector<array<ll,2>>edge(m+1);
	FOR(i,1,m){
        ll u,v;cin>>u>>v; 
        g[u].push_back(v);
    	edge[i]={u,v};
	}
    
    FOR(i,1,n){
        if(dfn[i])continue;
        top=0;
        tarjan(i,i);
    }
    FOR(i,1,m){
        ll u=edge[i][0],v=edge[i][1];
        u=scc[u],v=scc[v];
        if(u!=v)e[u].push_back(v),du[v]++;
    }
    ll res=topsort();
    cout<<res<<endl;

    return 0;
}
```

### 6.2-sat.

```c++
vector<ll>g[N];
ll vis[N];
ll dfn[N],low[N],st[N];
ll tot,top;
int cnt;
int scc[N];//每个点所在的连通块
void tarjan(ll u,ll fa){
    low[u]=dfn[u]=++tot;
    st[++top]=u;
    vis[u]=1;
    for(auto v:g[u]){
        if(!dfn[v]){
            tarjan(v,u);
            low[u]=min(low[u],low[v]); 
        }else if(vis[v])low[u]=min(low[u],dfn[v]);
    }
    if(low[u]==dfn[u]){
        cnt++;
        while(st[top+1]!=u){ //u以及后面的全部出栈，缩为一个点
            int tp=st[top--];
            vis[tp]=0;
            scc[tp]=cnt;
        }
    }
}
signed main(){IOS
    ll n;
    bool f=1;
	FOR(i,1,2*n)if(!dfn[i])tarjan(i,i);	
	FOR(i,1,n){
		if(scc[i]==scc[i+n])f=0;//无解
        //else if(scc[i]<scc[i+n]) 一般这种情况i为真值 （具体看情况赋值
	}
	if(f)cout<<"Yes"<<endl;
	else cout<<"No"<<endl;
	return 0;
}
```

### 7.树哈希.

```c++
//https://www.luogu.com.cn/problem/P5043

//复杂度： n*m*log(n)
struct Tree{
    ll a,b;
}f[N];
bool operator ==(Tree a,Tree b){
    return a.a==b.a&&a.b==b.b;
}
ll Pow[60];
vector<ll>g[N];
ll n;
ll rt,rrt,rtm;//重心（可能有2个）  重心最大子树和除最大子树外节点的差值（差值最小就是重心）
ll siz[N];
void findrt(ll u,ll fa){
    siz[u]=1;
    ll mx=0;
    for(auto v:g[u]){
        if(v==fa)continue;
        findrt(v,u);
        siz[u]+=siz[v];
        mx=max(mx,siz[v]);
    }
    mx=max(mx,n-siz[u]);
    if(mx<rtm)rtm=mx,rt=u,rrt=0;
    else if(mx==rtm)rrt=u;
}
ll tot=0;
ll has[N],dep[N];
pll sav[N];//按哈希值排序。
void dfs(ll u,ll fa){
    has[u]=dep[u]*Pow[1]%mod,siz[u]=1;
    for(auto v:g[u]){
        if(v==fa)continue;
        dep[v]=dep[u]+1;
        dfs(v,u);
    }
    tot=0;
    for(auto v:g[u]){
        if(v==fa)continue;
        sav[++tot]={has[v],siz[v]};//按哈希值排序。
    }
    sort(sav+1,sav+1+tot);
    FOR(i,1,tot){
        has[u]=(has[u]+sav[i].first*Pow[siz[u]]%mod)%mod;
        siz[u]+=sav[i].second;
    }
}

void cal(ll x){
    rtm=mod,rrt=0;
    cin>>n;
    FOR(i,1,n)g[i].clear();
    FOR(i,1,n){
        ll v;cin>>v;
        if(v)g[i].push_back(v),g[v].push_back(i);
    }
    findrt(1,-1);
    dep[rt]=1,dfs(rt,-1),f[x].a=has[rt];
    if(rrt)dep[rrt]=1,dfs(rrt,-1),f[x].b=has[rrt];
    if(f[x].a<f[x].b)swap(f[x].a,f[x].b);
}

signed main(){IOS
    Pow[0]=1;
    FOR(i,1,50)Pow[i]=Pow[i-1]*G%mod;
    ll m;cin>>m;
    FOR(i,1,m)cal(i);
    FOR(i,1,m)FOR(j,1,i)if(f[i]==f[j]){cout<<j<<endl;break;}
    return 0;
}


另版本
vector<ll>g[N];
ull h[N];
ull H(ull x) {
	return x * x * x * 1237123 + 19260817;
}
ull F(ull x) {
	return H(x & ((1ll << 32) - 1)) + H(x >> 32);
}
void treehash(ll u, ll fa) {
	h[u] = 1;  //h[u]可以为 base
	for (auto v : g[u]) {
		if (v == fa) {
			continue;
		}
		treehash(v, u);
		h[u] += F(h[v]);
	}
}
void solve() {
	ll n;
	scanf("%lld", &n);
	for (ll i = 1; i <= n; i++) {
		g[i].clear();
	}
	for (ll i = 1, u, v; i < n; i++) {
		scanf("%lld%lld", &u, &v);
		g[u].push_back(v);
		g[v].push_back(u);
	}
	treehash(1, 0);

}
```

### 8.无向图添边构造欧拉回路.

```c++
ll n,m;
ll adj[N][N],deg[N];
vector<array<ll,2>>edg;
bool vis[N];
void dfs(ll u){
    vis[u]=1;
    FOR(v,1,n){
        if(vis[v]||adj[u][v])continue;
        dfs(v);
        if(deg[v]){
            deg[v]^=1;deg[u]^=1;
            adj[u][v]=adj[v][u]=1;
            edg.push_back({u,v});
        }
    }
}

signed main(){IOS
    cin>>n>>m;
	FOR(i,1,m){
		ll u,v;cin>>u>>v;
		adj[u][v]=adj[v][u]=1;
		deg[u]^=1;deg[v]^=1;
	}
    FOR(u,1,n){
        if(vis[u])continue;
        dfs(u);
        if(deg[u]==1){
            cout<<-1<<endl;
            return 0;
        }
    }
    mem(vis,0);
    vector<vector<ll>>comp;//存连通块
    FOR(s,1,n){//得到连通块
        if(vis[s])continue;
        vector<ll>vec{s};
        vis[s]=1;
        for(ll i=0;i<vec.size();i++){
            ll u=vec[i];
            for(ll v=1;v<=n;v++){
                if(!vis[v]&&adj[u][v]){
                    vec.push_back(v);
                    vis[v]=1;
                }
            }
        }
        // cout<<vec.size()<<endl;
        comp.push_back(vec);
    }
    // cout<<comp.size()<<endl;
    if(comp.size()>=3){//连通块大于3个每个选一个点连成换
        for(int i=0;i<comp.size();i++){
            edg.push_back({comp[i][0],comp[(i+1)%comp.size()][0]});
        }
    }else if(comp.size()==2){
        if(comp[0].size()==1)swap(comp[0],comp[1]);//如果有大小为1特殊处理
        if(comp[1].size()>=2){//2个块都不是孤立点， 各选2个点构造
            edg.push_back({comp[0][0],comp[1][0]});
            edg.push_back({comp[1][0],comp[0][1]});
            edg.push_back({comp[0][1],comp[1][1]});
            edg.push_back({comp[1][1],comp[0][0]});
        }else if(!edg.empty()){//一个孤立点并且另一个图加过边，就把那个边删掉，加2条连孤点
            auto u=edg.back()[0],v=edg.back()[1];
            edg.pop_back();
            edg.push_back({u,comp[1][0]});
            edg.push_back({v,comp[1][0]});
        }else {//1个孤立点和另一个块没连边，就选2个不相邻的点试试能不能构造
            bool f=0;
            FOR(u,1,n){
                if(u==comp[1][0])continue;
                FOR(v,1,n){
                    if(v==comp[1][0]||adj[u][v]||u==v)continue;
                    f=1;
                    edg.push_back({u,v});
                    edg.push_back({u,comp[1][0]});
                    edg.push_back({comp[1][0],v});
                    break;
                }
                if(f)break;
            }
            if(!f){
                cout<<-1<<endl;
                return 0;
            }
        }   
    }
    cout<<edg.size()<<endl;
    for(auto to:edg){
        ll u=to[0],v=to[1];
        if(u>v)swap(u,v);
        cout<<u<<' '<<v<<endl;
    }
	return 0;
}
```

### 9.prufer序列.

![image-20230819141634719](C:\Users\leaf_maple\AppData\Roaming\Typora\typora-user-images\image-20230819141634719.png)

```c++
ll fat[N],pru[N];
ll du[N];
ll n,op;
void Topru(){
    FOR(i,1,n-1)du[fat[i]]++;
    for(int i=1,j=1;i<=n-2;i++,j++){
        while(du[j])j++;//找到第一个编号最小的度数为0的叶子
        pru[i]=fat[j];//叶子的父亲放入序列
        while(i<=n-2&&!--du[pru[i]]&&pru[i]<j){
            pru[i+1]=fat[pru[i]];
            i++;
        }
    }
}
void Tofat(){
    FOR(i,1,n-2)du[pru[i]]++;pru[n-1]=n;
    for(int i=1,j=1;i<=n-1;i++,j++){
        while(du[j])j++;
        fat[j]=pru[i];//当前的pru[i]是当前最小叶子的父亲
        while(i<n&&!--du[pru[i]]&&pru[i]<j){
            fat[pru[i]]=pru[i+1];
            i++;
        }
    }
}
signed main(){IOS
    cin>>n>>op;
    if(op==1){//本题默认 n 为根
        FOR(i,1,n-1)cin>>fat[i];//表示给出的父亲序列对应的 Prüfer 序列的权值
        Topru();
        ll res=0;FOR(i,1,n-2)res^=i*pru[i];
        //FOR(i,1,n-2)cout<<pru[i];
        cout<<res<<endl;
    }else {
        FOR(i,1,n-2)cin>>pru[i];//表示给出的 Prüfer 序列对应的父亲序列的权值
        Tofat();
        //FOR(i,1,n-1)cout<<fat[i];
        ll res=0;FOR(i,1,n-1)res^=i*fat[i];
        cout<<res<<endl;
    }
    return 0;
}
```

[有根树$purfer$应用](https://atcoder.jp/contests/arc162/tasks/arc162_d)

![image-20230904220135855](C:\Users\leaf_maple\AppData\Roaming\Typora\typora-user-images\image-20230904220135855.png)

($d_i$为出度)

![image-20230904220212728](C:\Users\leaf_maple\AppData\Roaming\Typora\typora-user-images\image-20230904220212728.png)

### 10.[支配树](https://www.luogu.com.cn/problem/P5180)

![image-20230819144842131](C:\Users\leaf_maple\AppData\Roaming\Typora\typora-user-images\image-20230819144842131.png)

```c++
#include <bits/stdc++.h>
#define For(i,a,b) for(int i=a;i<=b;i++)
#define Rev(i,a,b) for(int i=a;i>=b;i--)
#define Fin(file) freopen(file,"r",stdin)
#define Fout(file) freopen(file,"w",stdout)
using namespace std;
const int N=2e5+5; typedef long long ll;
class DominatorTree{
    int n,dfn[N],raw[N],dfscnt,semi[N],fa[N],pa[N],ffa[N][18],dep[N],in[N];
    vector<int> to[N],from[N],cp[N],cv[N];
    void dfs(int u){
        raw[dfn[u]=++dfscnt]=u; for(int v:to[u]) if(!dfn[v]) { cp[u].push_back(v); pa[v]=u; dfs(v); }
    }
    int getfa(int x){
        if(x!=fa[x]) { int t=getfa(fa[x]); semi[x]=min(semi[x],semi[fa[x]]); fa[x]=t; } return fa[x];
    }
    int lca(int x,int y){
        if(dep[x]<dep[y]) swap(x,y);
        Rev(i,17,0) if(dep[ffa[x][i]]>=dep[y]) x=ffa[x][i];
        if(x==y) return x;
        Rev(i,17,0) if(ffa[x][i]!=ffa[y][i]) { x=ffa[x][i]; y=ffa[y][i]; }
        return ffa[x][0];
    }
public:
    void init(int _n) { n=_n; }
    void add_edge(int x,int y) { to[x].push_back(y); from[y].push_back(x); }
    void solve(int* ans){
        dfs(1); assert(dfscnt==n);
        For(i,1,n) { fa[i]=i; semi[i]=dfn[i]; }
        Rev(i,n,2){
            int u=raw[i]; for(int w:from[u]) { getfa(w); semi[u]=min(semi[u],semi[w]); }
            fa[u]=pa[u]; cp[raw[semi[u]]].push_back(u); // Must do it right now!
        }
        For(u,1,n) for(int v:cp[u]) { cv[v].push_back(u); in[v]++; }
        static int q[N],h,t; h=t=0; q[t++]=1;
        while(h<t){
            int u=q[h++]; ans[u]=0;
            for(int v:cv[u]) if(ans[u]==0) ans[u]=v; else ans[u]=lca(ans[u],v);
            dep[u]=dep[ffa[u][0]=ans[u]]+1; For(i,1,17) ffa[u][i]=ffa[ffa[u][i-1]][i-1];
            for(int v:cp[u]) if((--in[v])==0) q[t++]=v;
        }
    }
}T;
int n,m,ans[N],siz[N]; vector<int> son[N];
void dfs(int u) { siz[u]=1; for(int v:son[u]) { dfs(v); siz[u]+=siz[v]; } }
signed main(){
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    cin>>n>>m; T.init(n); For(i,1,m) { int x,y; cin>>x>>y; T.add_edge(x,y); }  T.solve(ans);
    // For(i,1,n) cerr<<ans[i]<<' ';  cerr<<endl;
    For(i,2,n) son[ans[i]].push_back(i);
    dfs(1); For(i,1,n) cout<<siz[i]<<' '; cout<<endl;
    cerr<<"Time = "<<clock()<<" ms\n";
    return 0;
}

```



## 数学

### 1.矩阵.

```c++
//注意需不需要define int long long 
struct Mat {
    int v[105][105] = {0};
    int x, y;
    Mat() {}
    Mat(int _x, int _y) { x = _x, y = _y; }
    //清空
    void clear() { memset(v, 0, sizeof(v)); x = y = 0; }
    //单位矩阵化
    void I() { memset(v, 0, sizeof(v)); for (int i = 1; i <= x; i++)v[i][i] = 1; }
    //乘法
    void Mmul(Mat a, Mat b){
        clear(); x = a.x, y = b.y; int c = a.y;
        for (int i = 1; i <= x; ++i) {
            for (int j = 1; j <= y; ++j) {
                for (int k = 1; k <= c; ++k) {
                    v[i][j] += (long long)a.v[i][k] * b.v[k][j] % mod;
                    v[i][j] %= mod;
                }
            }
        }return;
    }
    //打印
    void show() {
        for (int i = 1; i <= x; i++) {
            for (int j = 1; j <= y; j++) {
                cout << v[i][j] << " ";
            }
            cout << endl;
        }
    }
};
Mat operator*(const Mat &x, const Mat &y) {
    Mat res;
    res.Mmul(x, y);
    return res;
}
Mat ksm(Mat a, long long b){
    Mat x = a; x.I();
    while (b) {
        if (b & 1) x = x * a;
        b >>= 1; a = a * a;
    }return x;
}
Mat operator+(const Mat& x, const Mat& y) {
    Mat res(x.x,x.y);
    for (int i = 1; i <= res.x; i++)
        for (int j = 1; j <= res.y; j++)
            res.v[i][j] = (x.v[i][j] + y.v[i][j]) % mod;
    return res;
}
Mat operator ^ (const Mat& a, long long b) {
    return ksm(a, b);
}
int n, k;
void slove() {
    cin >> n >> k;
    Mat mat(n, n);
    for (int i = 1; i <= n; i++)for (int j = 1; j <= n; j++)cin >> mat.v[i][j];
    mat = ksm(mat, k);
    mat.show();
}
```

### 2.容斥求互质的因子.

```c++
#define lowbit(a) ((a)&-(a))
#define lbit(a) (__builtin_ffsll(a))
#define ubit(a) (64-__builtin_clzll(a))
// 求1~n中与m互质的数的个数
// p为m的所有素因子集合
// 注意需不需要取模
vector<ll>p;
ll solve(ll n){
    ll ans = 0;
    ll ct=0;
    ct=p.size();
    for (int i = 1; i < (1 << ct); i++){   // ????????????
        ll tmp = 1, t = 0;
        ll x=i;
        for(;x;t++){
            tmp*=p[lbit(x)-1];
            x-=lowbit(x);
        }
        // while(x){
        //     ll j=lbit(x);
        //     tmp*=p[j-1];
        //     t++;
        //     x-=lowbit(x);
        // }
        ans += (t & 1 ? n / tmp : -n / tmp)%mod;        // ????
    }
    return (n - ans)%mod;
}
```

### 3.线性基.

```c++
vector<ull> B;
bool insert(ull x) {
    for (auto b : B)
        x = min(x, b ^ x);
    if(!x)return 0;//这个不需要插入
    for (auto &b : B)
        b = min(b, b ^ x);
    if (x)
        B.push_back(x);
    return 1;//这个需要插入
}
ll len;//len是原集合大小，也就是插入的数的数组
ll findk(ll k){//找第k小
    sort(B.begin(), B.end());
    ull ans = 0;
    if (B.size() < len)//线性基集合比原集合小，就代表能一异或出0
        k--;
    for (auto b : B) {
        if (k & 1)
            ans ^= b;
        k >>= 1;
    }
    return ans;
}
//可以查询区间异或最大值版本  
struct base{
	ll a[30] = {0};int t[30] = {0}; // 第 i 个基的插入时间 
	int cnt = 0; 
	void insert(ll x){
		int T = ++cnt; // 这个元素的插入次序
		for(int i=29; i>=0; i--){
			if(((x >> i) & 1) == 0) continue;
			if(a[i] == 0) {// 如果还没有元素
				a[i] = x;
				t[i] = T;
				break;
			}else {
				if(T > t[i]){
					swap(a[i], x);
					swap(t[i], T);
				} 
				x ^= a[i];
			}
		}
	}
	ll getmax(int l) {// 从l到当前cnt的所有基底的异或最大值
		ll res = 0;
		for(int i=29; i>=0; i--){
			if(t[i] >= l){
				res = max(res, res ^ a[i]);
			}	
		}
		return res;
	}
};
```

4.组合数.

```c++
ll fac[N],inv[N];
ll qpow(ll a,ll b){
	ll ans=1;
	while(b){
		if(b&1)ans=(ans*a)%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}
void prework(){	//预处理用于求阶乘
	fac[0]=1,inv[0]=1;
    for(int i=1;i<=N-5;i++){
        fac[i]=fac[i-1]*i%mod;
        fac[i]%=mod;
    }
    inv[N-5]=qpow(fac[N-5],mod-2);
    ROF(i,N-6,1)inv[i]=(inv[i+1]*(i+1))%mod;
}

ll C(ll n,ll m){
	if(n<0||m<0)return 0;
	if(m>n)return 0;
	return ((fac[n]%mod*inv[m])%mod*inv[n-m]%mod)%mod;
}

ll Lucas(ll n,ll m){
	return m==0?1:C(n%mod,m%mod)*Lucas(n/mod,m/mod)%mod;
}
```

### 4.欧拉筛.

```c++
正常版：
int pri[N], cnt;     // primes[]存储所有素数
int minp[N];  
void get_primes(int n) {
    for (int i = 2; i <= n; i += 1) {
        if (!minp[i]) pri[++cnt] = i, minp[i] = i ;
        for (int j = 1; pri[j]*i <= n && j<=cnt; j++) {
            minp[pri[j] * i] = pri[j];
            if (minp[i]==pri[j]) break;
        }
    }
}
带欧拉函数版本
void get_primes(int n) {
    phi[1]=1;
    for (int i = 2; i <= n; i += 1) {
        if (!minp[i]) primes[++cnt] = i, minp[i] = i , phi[i]=i-1;
        for (int j = 1; primes[j]*i <= n && j<=cnt; j++) {
            minp[primes[j] * i] = primes[j];
            if (minp[i]==primes[j]){
                phi[i * primes[j]] = phi[i] * primes[j];
                break;
            }
            phi[i * primes[j]] = phi[i] * (primes[j] - 1);
        }
    }
}
求莫比乌斯函数版本
int mul[N];
void get_primes(int n) {
    mul[1]=1;
    for (int i = 2; i <= n; i += 1) {
        if (!minp[i]) primes[++cnt] = i, minp[i] = i , mul[i] = -1;
        for (int j = 1; primes[j]*i <= n && j<=cnt; j++) {
            minp[primes[j] * i] = primes[j];
            if (minp[i]==primes[j]) {
                mul[primes[j] * i]=0;
                break;
            }
            mul[primes[j] * i]=-mul[i];
        }
    }
}
```



### 5.高斯消元

```c++
int n;
const double eps = 1e-10;
double a[N][N],b[N],ans[N];
/*拓展应用
1.求 矩阵 A的逆矩阵
方法： 将A矩阵变化成单位矩阵，同时让一个单位矩阵和A同步变化，
最后单位矩阵变成的样子就是A的逆矩阵
A E -> E A^(-1)
2.求矩阵A的行列式
方法： 将矩阵A变化成只剩对角线的情况，sign为进行 行交换 的次数，奇数为-1 偶数为1
       答案就是 对角线数之和*sign
*/
int gauss(){
    int l=1;
    for(int i=1;i<=n;i++){
        for(int j=l+1;j<=n;j++){
            if(abs(a[l][i]) < abs(a[j][i])){//将值最大的交换到这一行
                for(int k=i;k<=n;k++) swap(a[l][k],a[j][k]);
                swap(b[l],b[j]);
            }
        }
        if(abs(a[l][i])<eps) continue;
        for(int j=1;j<=n;j++)if(j!=l && abs(a[j][i]) >= eps){
            double delt = a[j][i]/a[l][i];
            for(int k = i; k <= n; k++) a[j][k] -= delt * a[l][k]; 
            b[j] -= delt * b[l];
        }
        l++;
    }
    //cout<<l<<endl;
    for(int i=l;i<=n;i++)if(abs(b[i])>=eps){
        return -1;
    }
    if(l<=n)return -2;
    for(int i=1;i<=n;i++) ans[i] = b[i]/a[i][i];
    return 0;
}

signed main(){IOS
    xs(9);
    cin>>n;
    FOR(i,1,n){
        FOR(j,1,n)cin>>a[i][j];
        cin>>b[i];
    }
    int f = gauss();
    if(f)cout<<f<<endl;
    else {
        FOR(i,1,n) cout<<ans[i]<<endl;
    }

    return 0;
}
```

### 6.组合数学板子

```c++
ll fac[N],inv[N];
ll qpow(ll a,ll b){
	ll ans=1;
	while(b){
		if(b&1)ans=(ans*a)%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}
void prework(){	//预处理用于求阶乘
	fac[0]=1,inv[0]=1;
    for(int i=1;i<=N-5;i++){
        fac[i]=fac[i-1]*i%mod;
        fac[i]%=mod;
    }
    inv[N-5]=qpow(fac[N-5],mod-2);
    ROF(i,N-6,1)inv[i]=(inv[i+1]*(i+1))%mod;
}

ll C(ll n,ll m){
	if(n<0||m<0)return 0;
	if(m>n)return 0;
	return ((fac[n]%mod*inv[m])%mod*inv[n-m]%mod)%mod;
}

ll Lucas(ll n,ll m){
	return m==0?1:C(n%mod,m%mod)*Lucas(n/mod,m/mod)%mod;
}
```

#### 模数不为素数时：

```c++
LL calc(LL n, LL x, LL P) {
  if (!n) return 1;
  LL s = 1;
  for (LL i = 1; i <= P; i++)
    if (i % x) s = s * i % P;
  s = Pow(s, n / P, P);
  for (LL i = n / P * P + 1; i <= n; i++)
    if (i % x) s = i % P * s % P;
  return s * calc(n / x, x, P) % P;
}

LL multilucas(LL m, LL n, LL x, LL P) {
  int cnt = 0;
  for (LL i = m; i; i /= x) cnt += i / x;
  for (LL i = n; i; i /= x) cnt -= i / x;
  for (LL i = m - n; i; i /= x) cnt -= i / x;
  return Pow(x, cnt, P) % P * calc(m, x, P) % P * inverse(calc(n, x, P), P) %
         P * inverse(calc(m - n, x, P), P) % P;
}

LL exlucas(LL m, LL n, LL P) {
  int cnt = 0;
  LL p[20], a[20];
  for (LL i = 2; i * i <= P; i++) {
    if (P % i == 0) {
      p[++cnt] = 1;
      while (P % i == 0) p[cnt] = p[cnt] * i, P /= i;
      a[cnt] = multilucas(m, n, i, p[cnt]);
    }
  }
  if (P > 1) p[++cnt] = P, a[cnt] = multilucas(m, n, P, P);
  return CRT(cnt, a, p);
}

```

### 7.min25求mul和phi

```c++
//P4213 min_25 
#include <bits/stdc++.h>
#define ll long long
#define pb push_back
#define mk make_pair
#define pii pair<int,int>
#define fst first
#define scd second
using namespace std;
/*  -----  by:duyi  -----  */
const int N=5e4;
const int MAXN=N*2+5;
int n,sn,cnt,tot,p[MAXN],sum[MAXN],id1[MAXN],id2[MAXN],val[MAXN];
ll g1[MAXN],g2[MAXN];
bool v[MAXN];
void sieve() {
	v[1]=1;
	for(int i=2;i<=N;++i) {
		if(!v[i]) p[++cnt]=i;
		for(int j=1;j<=cnt && (ll)i*p[j]<=N;++j) {
			v[i*p[j]]=1;
			if(i%p[j]==0) break;
		}
	}
	for(int i=1;i<=cnt;++i) sum[i]=sum[i-1]+p[i];
}
inline int get_id(int x) {
	if(x<=sn) return id1[x];
	else return id2[n/x];
}
ll S_phi(int x,int y) {
	if(x<=1 || p[y]>x) return 0;
	ll res=g1[get_id(x)]-g2[get_id(x)]-(sum[y-1]-(y-1));
	for(int i=y;i<=cnt && (ll)p[i]*p[i]<=x;++i) {
		ll pre=1,cur=p[i];
		for(int j=1;cur*p[i]<=x;++j) {
			res+=pre*(p[i]-1LL)*S_phi(x/cur,i+1)+cur*(p[i]-1LL);
			pre=cur;cur=cur*p[i];
		}
	}
	return res;
}
ll S_mu(int x,int y) {
	if(x<=1 || p[y]>x) return 0;
	ll res=-g2[get_id(x)]+y-1;
	for(int i=y;i<=cnt && (ll)p[i]*p[i]<=x;++i) {
		res+=(-S_mu(x/p[i],i+1));
	}
	return res;
}
void solve() {
	cin>>n;
	sn=sqrt(n);tot=0;
	for(int i=1,j;i<=n;i=j+1) {
		j=n/(n/i);int w=n/i;
		val[++tot]=w;
		if(w<=sn) id1[w]=tot;
		else id2[n/w]=tot;
		g1[tot]=(ll)w*(w+1LL)/2LL-1LL;
		g2[tot]=w-1;
	}
	for(int i=1;i<=cnt;++i) {
		for(int j=1;j<=tot && (ll)p[i]*p[i]<=val[j];++j) {
			int t=get_id(val[j]/p[i]);
			g1[j]-=(ll)p[i]*(g1[t]-sum[i-1]);
			g2[j]-=(g2[t]-(i-1));
		}
	}
	cout<<S_phi(n,1)+1LL<<" "<<S_mu(n,1)+1LL<<endl;
}
int main() {
	ios::sync_with_stdio(0);/*syn加速*/
	sieve();
	int T;cin>>T;while(T--)solve();
	return 0;
}

```

8.根号求mul和phi

```c++
 const int maxn = 5e6 + 10;
const int mod = 1e9 + 7; 
int prime[maxn], mu[maxn], check[maxn];
ll phi[maxn];
unordered_map<ll, int> ans_mu;
unordered_map<ll, ll> ans_phi;
void init() {
	mu[1] = 1;
	phi[1] = 1;
	int tot = 0;
	for(int i = 2; i <= maxn; i++) {
		if(!check[i]) {
			prime[tot++] = i;
			mu[i] = -1;
			phi[i] = i - 1;
		}
		for(int j = 0; j < tot; j++) {
			if(i * prime[j] > maxn) break;
			check[i * prime[j]] = true;
			if(i % prime[j] == 0) {
				mu[i * prime[j]] = 0;
				phi[i * prime[j]] = phi[i] * prime[j];
				break;
			}
			else{
				phi[i * prime[j]] = phi[i] * (prime[j] - 1);
				mu[i * prime[j]] = -mu[i];
			}
		}
	}
	for(int i = 1; i <= maxn; i++) {
		mu[i] += mu[i - 1];
		phi[i] += phi[i - 1];
	}
}
int get_mu(ll x) {
	if(x <= maxn) return mu[x];
	if(ans_mu[x]) return ans_mu[x];
	int ans = 1;
	for(ll l = 2, r; l <= x; l = r + 1){
    	r = x / (x / l);
    	ans -= (r - l + 1) * get_mu(x / l);
	}
	ans_mu[x] = ans;
	return ans;
}
ll get_phi(ll x) {
	if(x <= maxn) return phi[x];
	if(ans_phi[x]) return ans_phi[x];
	ll ans = (ll)(x + 1) * (ll)x / 2;
	for(ll l = 2, r; l <= x; l = r + 1){
    	r = x / (x / l);
    	ans -= (r - l + 1) * get_phi(x / l);
	}
	ans_phi[x] = ans;
	return ans;
}
```



## 数论

### 部分代码

```c++
//逆元
求1~n
inv[1]=1;
FOR(i,2,n)
    inv[i]=(p-p/i)*inv[p%i]%p;


// 欧几里得
ll gcd(ll a, ll b) {
    if (b == 0) return a;
    else return gcd(b, a % b);
}

// 快速幂
ll powmod(ll a, ll b, ll mod) {
    ll ret = 1;
    for (; b; b >>= 1) {
        if (b & 1) ret = ret * a % mod;
        a = a * a %mod;
    }
    return ret;
}


// 扩展欧几里得
ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    ll d = exgcd(b, a % b, y, x);
    y -= (a / b) * x;
    return d;
}

// 求 a * x = b (mod m) 的解
ll modequ(ll a, ll b, ll m) {
    ll x, y;
    ll d = exgcd(a, m, x, y);
    if (b % d != 0) return -1;
    m /= d; a /= d; b /= d;
    x = x * b % m;
    if (x < 0) x += m;
    return x;
}


// 合并两个同余方程
// 目前是 x%b=a  给的是 x%d=c；
void merge(ll &a, ll &b, ll c, ll d) { // d <= 10^9
    // bt = c - a(mod d)
    if (a == -1 && b == -1) return;
    ll x, y;
    ll g = exgcd(b, d, x, y);
    //bx = g(mod d)
    if ((c - a) % g != 0) {
        a = b = -1;
        return;
    }
    d /= g; // d'
    //ll t0 = ((c - a) / g) % d * x % d;
    ll t0= (__int128)x*(c-a)/g%d;
    if (t0 < 0) t0 += d;
    // t = t0 (mod d')
    a = b * t0 + a;
    b = b * d;
}

// 线性筛
    p[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!p[i]) p[i] = i, pr[++tot] = i;
        for (int j = 1; j <= tot && pr[j] * i <= n; j++) {
            p[i * pr[j]] = pr[j];
            if (p[i] == pr[j]) break;
        }
    }


//同余方程组模数互素时的另一种解法。
ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }
    ll d = exgcd(b, a % b, y, x);
    y -= (a / b) * x;
    return d;
}
ll CRT(int k, ll* a, ll* r) {
    ll n = 1, ans = 0;
    for (int i = 1; i <= k; i++) n = n * r[i];
    for (int i = 1; i <= k; i++) {
        ll m = n / r[i], b, y;
        exgcd(m, r[i], b, y);  // b * m mod r[i] = 1
        ans = (ans + a[i] * m * b % n) % n;
    }
  return (ans % n + n) % n;
}

ll mul(ll x,ll y,ll m){ //超过ll的取模
    x%=m,y%=mod;
    ll d=((long double)x*y/m);
    d=x*y-d*m;
    if(d>=m)d-=m;
    if(d<0)d+=m;
    return d;
}
```



### 1.原根相关.

```c++
struct Get_Omg {
    LL prime[50000];
    int tot = 0;
    LL gcd(LL a, LL b){
        return b ? gcd(b, a % b) : a;
    }
    void get_prime_factor(LL x) {       //质因数分解
        tot = 0;
        for (LL i = 2; i <= x / i; i ++) {
            if (x % i == 0) {
                prime[++ tot] = i;
                while (x % i == 0) x /= i;
            }
        }
        if (x > 1) prime[++ tot] = x;
    }
    bool check(LL x, LL p, LL ph){              //原根判定定理
//         if(qmi(x, p - 1, p) != 1) return false;
        for(int i = 1; i <= tot; i ++ ){
            if(qmi(x, ph / prime[i], p) == 1) return false;
        }
        return true;
    }
    LL getrt(LL p) {            //获得p的最小原根
        get_prime_factor(p - 1);
        for (LL a = 1; a < p; a ++) {
            if(check(a, p, p - 1)) return a;
        }
        return 0;
    }
    vector<int> getall(LL p){       //获得p的所有原根
        vector<int> ans;
        if(rt[p]) {
            int g = getrt(p);
            LL k = 1;
            for (int i = 1; i <= p - 1; i++) {
                k = k * g % p;
                if (gcd(i, p - 1) == 1) ans.push_back(k);
            }
//        sort(all(ans));       //如果要求有序, 可以排一下序
        }
        return ans;
    }
}omg;
```

### 2.BSGS.

```c++
// https://codeforces.com/group/6K18zNGBDB/contest/103486
// C题
// x[n] = a*x[n-1] + b %m 问是否有解
vector<ll>ans;
void BSGS(ll a,ll b,ll p){
    if(b==1)ans.push_back(0);
	// (a^x)%p = b%p    
	// ll x* = A*上取整(sqrt[p])-c   c=(0~上取整(sqrt[p]))
	// a^(A*y)=b*a^c  (同余%mod)
	// 解 x = A*y-c   ->  枚举A 
	if(a%p==b%p)ans.push_back(1);
	map<ll,ll>mp;
	ll y=sqrt(p)+1;
	ll base=b;
	FOR(i,0,y){   // ??? b*a^c
		mp[base]=i;
		(base*=a)%=p;
	}
	base=qpow(a,y,p);
	ll tmp=1;
	FOR(i,1,y+1){
		tmp=tmp*base%p;
		if(mp.count(tmp))ans.push_back(i*y-mp[tmp]);
	}
}

signed main(){IOS
    ll T;T=1;
    while(T--){
        ans.clear();
        ll a,b,s,p,v;cin>>a>>b>>p>>s>>v;
        mod=p;
        v%=mod;
        a%=mod;
        b%=mod;
        if(a==0){
            if(b==v||s==v)cout<<"YES"<<endl;
            else cout<<"NO"<<endl;
            return 0;
        }
        if(a==1){
            if(b==0){
                if(s==v)cout<<"YES"<<endl;
                else cout<<"NO"<<endl;
                return 0;
            }
            cout<<"YES"<<endl;
            continue;
        }
        ll x=v*(a-1)%mod+b;x%=mod;
        ll y=s*(a-1)%mod+b;y%=mod;
        if(!y){
            if(!x)cout<<"YES"<<endl;
            else cout<<"NO"<<endl;
            continue;
        }
        ll invy=qpow(y,mod-2,mod);
        ll bb=x*invy%mod;
        BSGS(a,bb,p);
        sort(ans.begin(),ans.end());
        if(ans.empty())cout<<"NO"<<endl;
        else cout<<"YES"<<endl;
    }
```



### 3.拉格朗日插值.

```c++
#define int long long
int n, m;
int x[N], y[N]; 
int pre[N], suf[N], inv[N];
int lagrange(int n, int *x, int *y, int xi){//求xi点处的f(xi)值, n表示从0到n的n + 1个点确定的多项式
    if(xi<0)return 0;
    if(xi<=n)return y[xi];
    int ans = 0;
    pre[0] = (xi - x[0]) % mod, suf[n + 1] = 1;
    for(int i = 1; i <= n; i ++ ) pre[i] = 1ll * pre[i - 1] * (xi - x[i] + mod) % mod;
    for(int i = n; i >= 0; i -- ) suf[i] = 1ll * suf[i + 1] * (xi - x[i]) % mod;
    //下面部分可以放到主函数
    inv[0] = inv[1] = 1;
    for(int i = 2; i <= n; i ++ ) inv[i] = -1ll * mod / i * inv[mod % i] % mod;
    for(int i = 2; i <= n; i ++ ) inv[i] = 1ll * inv[i] * inv[i - 1] % mod;
    //上面
    for(int i = 0; i <= n; i ++ )
    {
        ans = (ans + (1ll * y[i] * (i == 0 ? 1 : pre[i - 1])) % mod * suf[i + 1] % mod
                     * inv[i] % mod * (((n - i) & 1) ? -1 : 1) * inv[n - i] % mod + mod) % mod;
    }
    return (ans + mod) % mod;
}
 
int lagrange(int n, int *x, int *y, int xi) {//点不连续的情况
    int ans = 0;
    for (int i = 0; i <= n; i++) {
        int s1 = 1, s2 = 1;
        for (int j = 0; j <= n; j++)
            if (i != j) {
                s1 = 1ll*s1*(xi-x[j])%mod;
                s2 = 1ll*s2*(x[i]-x[j])%mod;
            }
        ans = (1ll*ans+1ll*y[i]*s1%mod*qpow(s2, mod-2)%mod)%mod;
    }
    return (ans+mod)%mod;
}

//求 1^k +2^k +3^k+....+n^k  n<=1e9  k<=1e6
signed main(){IOS
	cin>>n>>k;
	inv[0] = inv[1] = 1;
    for(int i = 2; i <= k+10; i ++ ) inv[i] = -1ll * mod / i * inv[mod % i] % mod;
    for(int i = 2; i <= k+10; i ++ ) inv[i] = 1ll * inv[i] * inv[i - 1] % mod;
	FOR(i,1,k+2)x[i]=i;
	FOR(i,1,k+2){
		y[i]=(y[i-1]+qpow(i,k))%mod;
	}
	ll res = lagrange(k+2,x,y,n);
	cout<<res<<endl;

	return 0;
}
```



### 4.FFT

dls的

```c++
//https://www.luogu.com.cn/problem/P3803
//多项式相乘
#include <bits/stdc++.h>
#define IOS   ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
using namespace std;
#define endl '\n'
#define rep(i, a, b) for (int i = a; i < (int)b; i++)
typedef long long ll;

// FFT_MAXN = 2^k
// fft_init() to precalc FFT_MAXN-th roots
typedef double db;
const int FFT_MAXN=1<<18, N = 1<<19;//大小根据数据范围调整，关系预处理的复杂度。
const long double pi=acosl(-1.0); //注意是cosl !!!
//constexpr double PI = 3.14159265358979323846;
struct cp{
    db a,b;
    cp operator+(const cp&y)const{return (cp){a+y.a,b+y.b};}
    cp operator-(const cp&y)const{return (cp){a-y.a,b-y.b};}
    cp operator*(const cp&y)const{return (cp){a*y.a-b*y.b,a*y.b+b*y.a};}
    cp operator!()const{return (cp){a,-b};};
}nw[FFT_MAXN+1];int bitrev[FFT_MAXN];
void dft(cp*a,int n,int flag=1){
	int d=0;while((1<<d)*n!=FFT_MAXN)d++;
	rep(i,0,n)if(i<(bitrev[i]>>d))swap(a[i],a[bitrev[i]>>d]);
	for (int l=2;l<=n;l<<=1){
		int del=FFT_MAXN/l*flag;
		for (int i=0;i<n;i+=l){
			cp *le=a+i,*ri=a+i+(l>>1),*w=flag==1?nw:nw+FFT_MAXN;
			rep(k,0,l>>1){
				cp ne=*ri**w;
				*ri=*le-ne,*le=*le+ne;
				le++,ri++,w+=del;
			}
		}
	}
	if(flag!=1)rep(i,0,n)a[i].a/=n,a[i].b/=n;
}
void fft_init(){
	int L=0;while((1<<L)!=FFT_MAXN)L++;
	bitrev[0]=0;rep(i,1,FFT_MAXN)bitrev[i]=bitrev[i>>1]>>1|((i&1)<<(L-1));
	nw[0]=nw[FFT_MAXN]=(cp){1,0};
	rep(i,0,FFT_MAXN+1)nw[i]=(cp){cos(2*pi/FFT_MAXN*i),sin(2*pi/FFT_MAXN*i)};	//very slow
}//注意是sinl还是sin, long double记得 + l

void convo(db*a,int n,db*b,int m,db*c){
	static cp f[FFT_MAXN>>1],g[FFT_MAXN>>1],t[FFT_MAXN>>1];
	int N=2;while(N<=n+m)N<<=1;
	rep(i,0,N)
		if(i&1){
			f[i>>1].b=(i<=n)?a[i]:0.0;
			g[i>>1].b=(i<=m)?b[i]:0.0;
		}else{
			f[i>>1].a=(i<=n)?a[i]:0.0;
			g[i>>1].a=(i<=m)?b[i]:0.0;
		}
	dft(f,N>>1);dft(g,N>>1);
	int del=FFT_MAXN/(N>>1);
	cp qua=(cp){0,0.25},one=(cp){1,0},four=(cp){4,0},*w=nw;
	rep(i,0,N>>1){
		int j=i?(N>>1)-i:0;
		t[i]=(four*!(f[j]*g[j])-(!f[j]-f[i])*(!g[j]-g[i])*(one+*w))*qua;
		w+=del;
	}
	dft(t,N>>1,-1);
	rep(i,0,n+m+1)c[i]=(i&1)?t[i>>1].a:t[i>>1].b;
}
// void mul(int *a,int *b,int n){// n<=N, 0<=a[i],b[i]<mo 任意模数fft
// 	static cp f[N],g[N],t[N],r[N];
// 	int nn=2;while(nn<=n+n)nn<<=1;
// 	rep(i,0,nn){
// 		f[i]=(i<=n)?(cp){(db)(a[i]>>15),(db)(a[i]&32767)}:(cp){0,0};
// 		g[i]=(i<=n)?(cp){(db)(b[i]>>15),(db)(b[i]&32767)}:(cp){0,0};
// 	}
// 	swap(n,nn);
// 	dft(f,n,1);dft(g,n,1);
// 	rep(i,0,n){
// 		int j=i?n-i:0;
// 		t[i]=( (f[i]+!f[j])*(!g[j]-g[i]) + (!f[j]-f[i])*(g[i]+!g[j]) )*(cp){0,0.25};
// 		r[i]=(!f[j]-f[i])*(!g[j]-g[i])*(cp){-0.25,0} + (cp){0,0.25}*(f[i]+!f[j])*(g[i]+!g[j]);
// 	}
// 	dft(t,n,-1); dft(r,n,-1);
// 	rep(i,0,n)a[i]=( (ll(t[i].a+0.5)%mo<<15) + ll(r[i].a+0.5) + (ll(r[i].b+0.5)%mo<<30) )%mo;
// }

db f[N], g[N], h[N];
int main() {IOS
	fft_init();
    int n,m;cin>>n>>m;
    for(int i=0;i<=n;i++)cin>>f[i];
    for(int i=0;i<=m;i++)cin>>g[i];
    convo(f,n,g,m,h);
    for(int i=0; i<=n+m; i++)cout<<(ll)(h[i]+0.5)<<" \n"[i==n+m+1];
    
}
```



### 5.NTT

相关题目: [1](//https://ac.nowcoder.com/acm/contest/26013/) [2](http://oj.daimayuan.top/course/30/problem/1273*) [3](https://codeforces.com/gym/103446/problem/B)

```c++
//http://oj.daimayuan.top/course/30/problem/1273
#include <bits/stdc++.h>
using namespace std;
#define IOS   ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define eb emplace_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef basic_string<int> BI;
typedef long long ll;
typedef pair<int,int> PII;
typedef double db;
const ll mod=998244353;
mt19937 mrand(random_device{}()); 
int rnd(int x) { return mrand() % x;}
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head

template<int MOD, int RT> struct mint {
	static const int mod = MOD;
	static constexpr mint rt() { return RT; } // primitive root for FFT
	int v; explicit operator int() const { return v; } // explicit -> don't silently convert to int
	mint():v(0) {}
	mint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);
		if (v < 0) v += MOD; }
	bool operator==(const mint& o) const {
		return v == o.v; }
	friend bool operator!=(const mint& a, const mint& b) { 
		return !(a == b); }
	friend bool operator<(const mint& a, const mint& b) { 
		return a.v < b.v; }
   
	mint& operator+=(const mint& o) { 
		if ((v += o.v) >= MOD) v -= MOD; 
		return *this; }
	mint& operator-=(const mint& o) { 
		if ((v -= o.v) < 0) v += MOD; 
		return *this; }
	mint& operator*=(const mint& o) { 
		v = int((ll)v*o.v%MOD); return *this; }
	mint& operator/=(const mint& o) { return (*this) *= inv(o); }
	friend mint pow(mint a, ll p) {
		mint ans = 1; assert(p >= 0);
		for (; p; p /= 2, a *= a) if (p&1) ans *= a;
		return ans; }
	friend mint inv(const mint& a) { assert(a.v != 0); 
		return pow(a,MOD-2); }
		
	mint operator-() const { return mint(-v); }
	mint& operator++() { return *this += 1; }
	mint& operator--() { return *this -= 1; }
	friend mint operator+(mint a, const mint& b) { return a += b; }
	friend mint operator-(mint a, const mint& b) { return a -= b; }
	friend mint operator*(mint a, const mint& b) { return a *= b; }
	friend mint operator/(mint a, const mint& b) { return a /= b; }
};

const int MOD=998244353; 
using mi = mint<MOD,5>; // 5 is primitive root for both common mods

namespace simp {
	vector<mi> fac,ifac,invn;
	void check(int x) {
		if (fac.empty()) {
			fac={mi(1),mi(1)};
			ifac={mi(1),mi(1)};
			invn={mi(0),mi(1)};
		}
		while (SZ(fac)<=x) {
			int n=SZ(fac),m=SZ(fac)*2;
			fac.resize(m);
			ifac.resize(m);
			invn.resize(m);
			for (int i=n;i<m;i++) {
				fac[i]=fac[i-1]*mi(i);
				invn[i]=mi(MOD-MOD/i)*invn[MOD%i];
				ifac[i]=ifac[i-1]*invn[i];
			}
		}
	}
	mi gfac(int x) {
		check(x); return fac[x];
	}
	mi ginv(int x) {
		check(x); return invn[x];
	}
	mi gifac(int x) {
		check(x); return ifac[x];
	}
	mi binom(int n,int m) {
		if (m < 0 || m > n) return mi(0);
		return gfac(n)*gifac(m)*gifac(n - m);
	}
}

const int md = 998244353;

inline void add(int &x, int y) {
  x += y;
  if (x >= md) {
    x -= md;
  }
}

inline void sub(int &x, int y) {
  x -= y;
  if (x < 0) {
    x += md;
  }
}

inline int mul(int x, int y) {
  return (long long) x * y % md;
}

inline int power(int x, int y) {
  int res = 1;
  for (; y; y >>= 1, x = mul(x, x)) {
    if (y & 1) {
      res = mul(res, x);
    }
  }
  return res;
}

inline int inv(int a) {
  a %= md;
  if (a < 0) {
    a += md;
  }
  int b = md, u = 0, v = 1;
  while (a) {
    int t = b / a;
    b -= t * a;
    swap(a, b);
    u -= t * v;
    swap(u, v);
  }
  if (u < 0) {
    u += md;
  }
  return u;
}

namespace ntt {
int base = 1, root = -1, max_base = -1;
vector<int> rev = {0, 1}, roots = {0, 1};

void init() {
  int temp = md - 1;
  max_base = 0;
  while (temp % 2 == 0) {
    temp >>= 1;
    ++max_base;
  }
  root = 2;
  while (true) {
    if (power(root, 1 << max_base) == 1 && power(root, 1 << (max_base - 1)) != 1) {
      break;
    }
    ++root;
  }
}

void ensure_base(int nbase) {
  if (max_base == -1) {
    init();
  }
  if (nbase <= base) {
    return;
  }
  assert(nbase <= max_base);
  rev.resize(1 << nbase);
  for (int i = 0; i < 1 << nbase; ++i) {
    rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (nbase - 1));
  }
  roots.resize(1 << nbase);
  while (base < nbase) {
    int z = power(root, 1 << (max_base - 1 - base));
    for (int i = 1 << (base - 1); i < 1 << base; ++i) {
      roots[i << 1] = roots[i];
      roots[i << 1 | 1] = mul(roots[i], z);
    }
    ++base;
  }
}

void dft(vector<int> &a) {
  int n = a.size(), zeros = __builtin_ctz(n);
  ensure_base(zeros);
  int shift = base - zeros;
  for (int i = 0; i < n; ++i) {
    if (i < rev[i] >> shift) {
      swap(a[i], a[rev[i] >> shift]);
    }
  }
  for (int i = 1; i < n; i <<= 1) {
    for (int j = 0; j < n; j += i << 1) {
      for (int k = 0; k < i; ++k) {
        int x = a[j + k], y = mul(a[j + k + i], roots[i + k]);
        a[j + k] = (x + y) % md;
        a[j + k + i] = (x + md - y) % md;
      }
    }
  }
}

vector<int> multiply(vector<int> a, vector<int> b) {
  int need = a.size() + b.size() - 1, nbase = 0;
  while (1 << nbase < need) {
    ++nbase;
  }
  ensure_base(nbase);
  int sz = 1 << nbase;
  a.resize(sz);
  b.resize(sz);
  bool equal = a == b;
  dft(a);
  if (equal) {
    b = a;
  } else {
    dft(b);
  }
  int inv_sz = inv(sz);
  for (int i = 0; i < sz; ++i) {
    a[i] = mul(mul(a[i], b[i]), inv_sz);
  }
  reverse(a.begin() + 1, a.end());
  dft(a);
  a.resize(need);
  return a;
}

vector<int> inverse(vector<int> a) {
  int n = a.size(), m = (n + 1) >> 1;
  if (n == 1) {
    return vector<int>(1, inv(a[0]));
  } else {
    vector<int> b = inverse(vector<int>(a.begin(), a.begin() + m));
    int need = n << 1, nbase = 0;
    while (1 << nbase < need) {
      ++nbase;
    }
    ensure_base(nbase);
    int sz = 1 << nbase;
    a.resize(sz);
    b.resize(sz);
    dft(a);
    dft(b);
    int inv_sz = inv(sz);
    for (int i = 0; i < sz; ++i) {
      a[i] = mul(mul(md + 2 - mul(a[i], b[i]), b[i]), inv_sz);
    }
    reverse(a.begin() + 1, a.end());
    dft(a);
    a.resize(n);
    return a;
  }
}
}

using ntt::multiply;
using ntt::inverse;

vector<int>& operator += (vector<int> &a, const vector<int> &b) {
  if (a.size() < b.size()) {
    a.resize(b.size());
  }
  for (int i = 0; i < b.size(); ++i) {
    add(a[i], b[i]);
  }
  return a;
}

vector<int> operator + (const vector<int> &a, const vector<int> &b) {
  vector<int> c = a;
  return c += b;
}

vector<int>& operator -= (vector<int> &a, const vector<int> &b) {
  if (a.size() < b.size()) {
    a.resize(b.size());
  }
  for (int i = 0; i < b.size(); ++i) {
    sub(a[i], b[i]);
  }
  return a;
}

vector<int> operator - (const vector<int> &a, const vector<int> &b) {
  vector<int> c = a;
  return c -= b;
}

vector<int>& operator *= (vector<int> &a, const vector<int> &b) {
  if (min(a.size(), b.size()) < 128) {
    vector<int> c = a;
    a.assign(a.size() + b.size() - 1, 0);
    for (int i = 0; i < c.size(); ++i) {
      for (int j = 0; j < b.size(); ++j) {
        add(a[i + j], mul(c[i], b[j]));
      }
    }
  } else {
    a = multiply(a, b);
  }
  return a;
}

vector<int> operator * (const vector<int> &a, const vector<int> &b) {
  vector<int> c = a;
  return c *= b;
}

vector<int>& operator /= (vector<int> &a, const vector<int> &b) {
  int n = a.size(), m = b.size();
  if (n < m) {
    a.clear();
  } else {
    vector<int> c = b;
    reverse(a.begin(), a.end());
    reverse(c.begin(), c.end());
    c.resize(n - m + 1);
    a *= inverse(c);
    a.erase(a.begin() + n - m + 1, a.end());
    reverse(a.begin(), a.end());
  }
  return a;
}

vector<int> operator / (const vector<int> &a, const vector<int> &b) {
  vector<int> c = a;
  return c /= b;
}

vector<int>& operator %= (vector<int> &a, const vector<int> &b) {
  int n = a.size(), m = b.size();
  if (n >= m) {
    vector<int> c = (a / b) * b;
    a.resize(m - 1);
    for (int i = 0; i < m - 1; ++i) {
      sub(a[i], c[i]);
    }
  }
  return a;
}

vector<int> operator % (const vector<int> &a, const vector<int> &b) {
  vector<int> c = a;
  return c %= b;
}

vector<int> derivative(const vector<int> &a) {
  int n = a.size();
  vector<int> b(n - 1);
  for (int i = 1; i < n; ++i) {
    b[i - 1] = mul(a[i], i);
  }
  return b;
}

vector<int> primitive(const vector<int> &a) {
  int n = a.size();
  vector<int> b(n + 1), invs(n + 1);
  for (int i = 1; i <= n; ++i) {
    invs[i] = i == 1 ? 1 : mul(md - md / i, invs[md % i]);
    b[i] = mul(a[i - 1], invs[i]);
  }
  return b;
}

vector<int> logarithm(const vector<int> &a) {
  vector<int> b = primitive(derivative(a) * inverse(a));
  b.resize(a.size());
  return b;
}

vector<int> exponent(const vector<int> &a) {
  vector<int> b(1, 1);
  while (b.size() < a.size()) {
    vector<int> c(a.begin(), a.begin() + min(a.size(), b.size() << 1));
    add(c[0], 1);
    vector<int> old_b = b;
    b.resize(b.size() << 1);
    c -= logarithm(b);
    c *= old_b;
    for (int i = b.size() >> 1; i < b.size(); ++i) {
      b[i] = c[i];
    }
  }
  b.resize(a.size());
  return b;
}

vector<int> power(vector<int> a, int m) {
  int n = a.size(), p = -1;
  vector<int> b(n);
  for (int i = 0; i < n; ++i) {
    if (a[i]) {
      p = i;
      break;
    }
  }
  if (p == -1) {
    b[0] = !m;
    return b;
  }
  if ((long long) m * p >= n) {
    return b;
  }
  int mu = power(a[p], m), di = inv(a[p]);
  vector<int> c(n - m * p);
  for (int i = 0; i < n - m * p; ++i) {
    c[i] = mul(a[i + p], di);
  }
  c = logarithm(c);
  for (int i = 0; i < n - m * p; ++i) {
    c[i] = mul(c[i], m);
  }
  c = exponent(c);
  for (int i = 0; i < n - m * p; ++i) {
    b[i + m * p] = mul(c[i], mu);
  }
  return b;
}

vector<int> sqrt(const vector<int> &a) {
  vector<int> b(1, 1);
  while (b.size() < a.size()) {
    vector<int> c(a.begin(), a.begin() + min(a.size(), b.size() << 1));
    vector<int> old_b = b;
    b.resize(b.size() << 1);
    c *= inverse(b);
    for (int i = b.size() >> 1; i < b.size(); ++i) {
      b[i] = mul(c[i], (md + 1) >> 1);
    }
  }
  b.resize(a.size());
  return b;
}

vector<int> multiply_all(int l, int r, vector<vector<int>> &all) {
  if (l > r) {
    return vector<int>();
  } else if (l == r) {
    return all[l];
  } else {
    int y = (l + r) >> 1;
    return multiply_all(l, y, all) * multiply_all(y + 1, r, all);
  }
}

vector<int> evaluate(const vector<int> &f, const vector<int> &x) {
  int n = x.size();
  if (!n) {
    return vector<int>();
  }
  vector<vector<int>> up(n * 2);
  for (int i = 0; i < n; ++i) {
    up[i + n] = vector<int>{(md - x[i]) % md, 1};
  }
  for (int i = n - 1; i; --i) {
    up[i] = up[i << 1] * up[i << 1 | 1];
  }
  vector<vector<int>> down(n * 2);
  down[1] = f % up[1];
  for (int i = 2; i < n * 2; ++i) {
    down[i] = down[i >> 1] % up[i];
  }
  vector<int> y(n);
  for (int i = 0; i < n; ++i) {
    y[i] = down[i + n][0];
  }
  return y;
}

vector<int> interpolate(const vector<int> &x, const vector<int> &y) {
  int n = x.size();
  vector<vector<int>> up(n * 2);
  for (int i = 0; i < n; ++i) {
    up[i + n] = vector<int>{(md - x[i]) % md, 1};
  }
  for (int i = n - 1; i; --i) {
    up[i] = up[i << 1] * up[i << 1 | 1];
  }
  vector<int> a = evaluate(derivative(up[1]), x);
  for (int i = 0; i < n; ++i) {
    a[i] = mul(y[i], inv(a[i]));
  }
  vector<vector<int>> down(n * 2);
  for (int i = 0; i < n; ++i) {
    down[i + n] = vector<int>(1, a[i]);
  }
  for (int i = n - 1; i; --i) {
    down[i] = down[i << 1] * up[i << 1 | 1] + down[i << 1 | 1] * up[i << 1];
  }
  return down[1];
}

int cnt[20];
//从集合中选出奇数个数字，使得和为m
int main() {IOS
    int n,m; cin>>n>>m;
    for(int i=1; i<=n; i++){
        int x; cin>>x;
        cnt[x]++;
    }   
    vector<vector<int>>FA,FB;
    for(int i=1; i<=10; i++){
        vector<int>A(cnt[i]*i+1,0);
        vector<int>B(cnt[i]*i+1,0);
        for(int j=0;j<=cnt[i];j++){
            int x = (int) simp::binom(cnt[i],j); 
            A[i*j]=x;
            B[i*j]=(j%2 ? (mod-x) % mod : x );
        }
        FA.push_back(A);
        FB.push_back(B);
    }
    auto A = multiply_all(0,9,FA);
    auto B = multiply_all(0,9,FB);
    if(A.size()<=m){
        cout<<0<<endl;
        return 0;
    }
    ll res1 = A[m];
    ll res2 = B[m];
    ll res = (res1-res2)*inv(2)%mod;
    res = (res + mod)%mod;
    cout<<res<<endl;
}
```

### 6.大数判断质数（得到最大质因子）：

```c++
#include <bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof(a));
#define endl '\n'
using namespace std;
using ll = long long;
const int N=1e6+5;
const int mod=998244353;

int t;
long long max_factor, n;

long long gcd(long long a, long long b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

long long quick_pow(long long x, long long p, long long mod) {  // 快速幂
    long long ans = 1;
    while (p) {
        if (p & 1) ans = (__int128)ans * x % mod;
        x = (__int128)x * x % mod;
        p >>= 1;
    }
    return ans;
}

bool Miller_Rabin(long long p) {  // 判断素数
    if (p < 2) return 0;
    if (p == 2) return 1;
    if (p == 3) return 1;
    long long d = p - 1, r = 0;
    while (!(d & 1)) ++r, d >>= 1;  // 将d处理为奇数
    for (long long k = 0; k < 10; ++k) {
        long long a = rand() % (p - 2) + 2;
        long long x = quick_pow(a, d, p);
        if (x == 1 || x == p - 1) continue;
        for (int i = 0; i < r - 1; ++i) {
        x = (__int128)x * x % p;
        if (x == p - 1) break;
        }
        if (x != p - 1) return 0;
    }
    return 1;
}

long long Pollard_Rho(long long x) {
    long long s = 0, t = 0;
    long long c = (long long)rand() % (x - 1) + 1;
    int step = 0, goal = 1;
    long long val = 1;
    for (goal = 1;; goal *= 2, s = t, val = 1) {  // 倍增优化
        for (step = 1; step <= goal; ++step) {
        t = ((__int128)t * t + c) % x;
        val = (__int128)val * abs(t - s) % x;
        if ((step % 127) == 0) {
            long long d = gcd(val, x);
            if (d > 1) return d;
        }
        }
        long long d = gcd(val, x);
        if (d > 1) return d;
    }
}

void fac(long long x) {
    if (x <= max_factor || x < 2) return;
    if (Miller_Rabin(x)) {              // 如果x为质数
        max_factor = max(max_factor, x);  // 更新答案
        return;
    }
    long long p = x;
    while (p >= x) p = Pollard_Rho(x);  // 使用该算法
    while ((x % p) == 0) x /= p;
    fac(x), fac(p);  // 继续向下分解x和p
}

int main() {
    cin.tie(0)->sync_with_stdio(0);
    cin>>t;
    int fk = 0;
    while (t--) {
        fk++;
        srand((unsigned)time(NULL));
        max_factor = 0;
        cin>>n;
        // n=fk;
        if(n==1){
            cout<<1<<' ';
            continue;
        }
        fac(n);
        if (max_factor == n)  // 最大的质因数即自己
            cout<<n%mod<<' ';
        else {
            while(n%max_factor==0)n/=max_factor;
            if(n==1)cout<<max_factor%mod<<' ';
            else cout<<1<<' ';
        }
    }
    cout<<endl;
  return 0;
}

```



## 字符串

### 1.hash.

```c++
#define mp make_pair
#define fi first
#define se second
#define int long long
typedef pair<int,int> hashv;
map<hashv,ll>mmp;
const ll mod1=1000000007;
const ll mod2=1000000009;
hashv operator + (hashv a,hashv b) {
	int c1=a.fi+b.fi,c2=a.se+b.se;
	if (c1>=mod1) c1-=mod1;
	if (c2>=mod2) c2-=mod2;
	return mp(c1,c2);
}
hashv operator - (hashv a,hashv b) {
	int c1=a.fi-b.fi,c2=a.se-b.se;
	if (c1<0) c1+=mod1;
	if (c2<0) c2+=mod2;
	return mp(c1,c2);
}
hashv operator * (hashv a,hashv b) {
	return mp(1ll*a.fi*b.fi%mod1,1ll*a.se*b.se%mod2);
}
hashv pw[N],s[N],t[N];
string tt[N];
hashv get(ll l,ll r){
    return ((t[r]-t[l-1]*pw[r-l+1]));
}
signed main(){
    hashv base=mp(13331,23333);
	pw[0]=mp(1,1);
	for (int i=1;i<=n;i++) {//前缀哈希
		pw[i]=pw[i-1]*base,s[i]=s[i-1]*base+mp(tt[i],tt[i]);
	}
    per(i,1,n+1) t[i]=t[i+1]*base+mp(tt[i],tt[i]);//后缀哈希
}

```

### 2.Z函数 (exkmp).

```c++
int z[N]; //  i~i+k-1 与 1~k 相等 k=z[i] 最长的k
void get_Z(string s){//下标从1开始
    int L=1,R=0;
    int n=s.size()-1;
    for(int i=2;i<=n;i++){
        z[i]=0;
        if(i<=R){
            int d=i-L+1;
            z[i]=min(z[d],R-i+1);
        }
        while(i<=n&&s[i+z[i]]==s[1+z[i]])z[i]++;
        if(i+z[i]-1>R)L=i,R=i+z[i]-1;
    }
}

```

### 3.kmp.

```c++
int nxt[N];
void get_nxt(string s){ //处理待查找串
    int n=s.size();
    s=" "+s;
    for(int i=2,j=0;i<=n;i++){
        while(j&&s[i]!=s[j+1])j=nxt[j];
        if(s[i]==s[j+1])j++;
        nxt[i]=j;
    }
}
vector<int> kmp(string s,string t){ // 从s里找t  得到所有满足的开始下标
    vector<int>res; 
    int n=s.size(),m=t.size();s=" "+s;t=" "+t;
    for(int i=1,j=0;i<=n;i++){
        while(j==m||(j&&s[i]!=t[j+1]))j=nxt[j];
        if(s[i]==t[j+1])j++;
        if(j==m)res.push_back(i-m+1);
    }
    return res;
}

void solve(){
    string s,t;cin>>s>>t;
    get_nxt(t);
    vector<int>res = kmp(s,t);
    if(res.empty())cout<<"-1\n-1\n";
    else {
        cout<<res.size()<<endl;
        for(auto v:res)cout<<v<<' ';
        cout<<endl;
    }
}
```

### 4.AC自动机

求每个字符串在所有字符串中一共出现了多少次。

```c++
const int M=26;
struct node{
    node *son[M],*fail,*go[M];
    int cnt;
}pool[N],*cur=pool,*d[300],*q[N],*root;

node *newnode(){
    return cur++;
}
int t;//记录bfs序列，本题需要
void build(){//创建AC自动机
    q[t++]=root;
    for(int i=0;i<t;i++){
        node *u=q[i];
        for(int j=0;j<26;j++){
            if(u->son[j]){
                u->go[j] = u->son[j];
                if(u!=root)u->go[j]->fail = u->fail->go[j];//子节点回跳边 指向当前节点回跳边 的相同字符
                else u->go[j]->fail = root;//当前点是根节点 子节点的回跳边指向根
                q[t++] = u->son[j];
            }else {
                if(u!=root)u->go[j]=u->fail->go[j];//指向回跳边指向的跳转边，一步到位
                else u->go[j] = root;
            }
        }
    }
}
string S_tot;
void insert(string s,ll id){//创建字典树
    node *p=root;
    for(auto c:s){
        S_tot.push_back(c);//把所有输入过的单词存入S_tot
        int w=c-'a';
        if(!p->son[w])p->son[w]=newnode();
        p=p->son[w];
    }
    d[id]=p; // 记录单词结束所在的字典树编号  本题需要
}

signed main(){IOS
    ll n;cin>>n; // n<=200  |S|<=1e6
    root = newnode();
    FOR(i,1,n){
        string s;cin>>s;
        insert(s,i);
        S_tot.push_back('0');//用0分割不同单词
    }
    build();
    node *p = root;
    for(auto c:S_tot){
        if(c=='0')p=root;
        else p = p->go[c-'a'];
        p->cnt++;
    }
    for (int i = t - 1; i; i--) {
		q[i]->fail->cnt += q[i]->cnt;
	}
    FOR(i,1,n){
        cout<<d[i]->cnt<<endl;
    }
    return 0;
}
```

### 5.SA

```c++
const int N = 101000;
char s[N];
int sa[N], rk[N], ht[N], n;
// 0-based sa 表示第i大的为哪个，rk 表示第i个后缀第几大
// ht表示 lcp(sa[i], sa[i-1])
//本质不同字串个数：n*(n + 1) / 2 - sum(ht);
//可重叠最长重复子串： max(ht);
//不可重叠：二分长度L，将相邻两项ht大于等于L的分组，找到每组中最早出现和最晚出现的，判断是否重叠
//可重叠重复k次子串，二分长度L，将相邻两项ht大于等于L的分组，是否有一组大于k
//多串用分隔符链接，二分答案，两个串可以用并查集维护所在组的信息。
//平方串：枚举长度L，分段，每段求LCP和LCS，能连起来就是平方串，有多少个平方串也可以顺便求出来
void buildSA(char *s, int *sa, int *rk, int *ht, int n, int m = 128) {
	static int x[N], y[N], c[N];
	//vector<int> x(n * 2 + 10), y(n * 2 + 10), c(max(n, m) * 2 + 10);
	s[n] = 0;
	for (int i = 0; i < m; i++) c[i] = 0;
	for (int i = 0; i < n; i++) c[x[i] = s[i]]++;
	for (int i = 1; i < m; i++) c[i] += c[i - 1];
	for (int i = n - 1; i >= 0; i--) sa[--c[x[i]]] = i;
	for (int k = 1; k < n; k <<= 1) {
		int p=0;
		for (int i = n - 1; i >= n - k; i--) y[p++] = i;
		for (int i = 0; i < n; i++) if (sa[i] >= k) y[p++] = sa[i] - k;
		for (int i = 0; i < m; i++) c[i] = 0;
		for (int i = 0; i < n; i++) c[x[y[i]]]++;
		for (int i = 1; i < m; i++) c[i] += c[i - 1];
		for (int i = n - 1; i >= 0; i--) sa[--c[x[y[i]]]] = y[i];
		for (int i = 0; i <= n; i++) swap(x[i],y[i]);
		p = 1; x[sa[0]] = 0; y[n] = -1;
		for (int i = 1; i < n; i++) {
			if (y[sa[i - 1]] == y[sa[i]] && y[sa[i - 1] + k] == y[sa[i] + k])
				x[sa[i]] = p - 1;
			else
				x[sa[i]] = p++;
		}
		if (p == n) break;
		m = p;
	}
	for (int i = 0; i < n; i++) rk[sa[i]] = i;
	int k = 0;
	for (int i = 0; i < n; i++) {
		k = max(k - 1, 0);
		if (rk[i] == 0) continue;
		int j = sa[rk[i] - 1];
		while (s[i + k] == s[j + k]) k++;
		ht[rk[i]] = k;
	}
}
struct qwq{
	int st[21][N];
	void create(int *ht){
		//for(int i=0;i<=20;i++)FOR(j,1,n)st[i][j]=1e9;
		for(int i=0;i<n;i++)st[0][i]=ht[i];
		for(int i=1;i<=20;i++){
			for(int j=0;j+(1<<(i-1))<n;j++){
				st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);
			}
		}
	}
	int query(int l,int r){
		int len=31-__builtin_clz(r-l+1);
		return min(st[len][l],st[len][r-(1<<len)+1]);
	}
}RMQ;
int LCP(int u, int v) {
	if (u == v) return n - u;
	if (rk[u] > rk[v]) swap(u, v);
	return RMQ.query(rk[u] + 1, rk[v]);
}

int main() {IOS
	scanf("%s", s);
	n = strlen(s);
	buildSA(s, sa, rk, ht, n);
	for (int i = 0; i < n; i++) printf("%d ", sa[i] + 1); puts("");
	for (int i = 1; i < n; i++) printf("%d ", ht[i]); puts("");
}
```

### 6.SAM

```c++
//==========板子=================================来自懵哥
const int N = 2000005;
struct node {
    int ch[26];
    int len;
    int father;
};
struct node t[2 * N + 5];
int last = 1, ind = 1;
int siz[2 * N];
int ed[2 * N];//添加部分   记录s[1,id]对应SAM的位置
void insert(int c, int id){
    int p = last;
    int np = last = ++ind;
    t[np].len = t[p].len + 1;
    siz[np] = 1;
    ed[id] = np;//添加部分
    for (; p && !t[p].ch[c]; p = t[p].father) t[p].ch[c] = np;
    if (!p) t[np].father = 1;
    else{
        int q = t[p].ch[c];
        if (t[p].len + 1 == t[q].len) t[np].father = q;
        else{
            int nq = ++ind;
            t[nq] = t[q];
            t[nq].len = t[p].len + 1;
            t[q].father = t[np].father = nq;
            for (; p && t[p].ch[c] == q; p = t[p].father) t[p].ch[c] = nq;
        }
    }
}
//==========板子=================================

/*
给定一个只包含小写字母的字符串 S。
请你求出 S 的所有出现次数不为 1 的子串的出现次数乘上该子串长度的最大值。
*/
vector<int>g[2 * N];
string s;
ll ans = 0;
void dfs(int u, int fa) {
    for (int v : g[u]) {
        if (v == fa)continue;
        dfs(v, u);
        siz[u] += siz[v];
    }
    if (siz[u] != 1)ans = max(ans, (ll)t[u].len*siz[u]);
}
void slove() {
    cin >> s;
    int n = s.length();
    for (int i = 1; i <= n; i++)insert(s[i - 1] - 'a',i);//在线插入字符串
    for (int i = 2; i <= ind; i++) { //得到sam建出的树
        g[t[i].father].push_back(i);
    }
    dfs(1, 0);
    cout << ans << endl;
}
```

### 7.SAM功能集合

```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
//#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=3e5+10;//字符串长度 
const int maxc=26;
char s[maxn];
struct Suffix_Automaton {//打*的不一定用到 
    int next[maxn<<1][maxc];  //状态转移(尾部加一个字符的下一个状态)
	int len[maxn<<1]; //最长子串的长度(该节点子串数量=len[x]-len[link[x]])
	int link[maxn<<1];   //后缀链接(最短串前部减少一个字符所到达的状态)
//	int cnt[maxn<<1];   //被后缀连接的数(*） 
	int id; //结点编号
	int last; //最后结点
	int endpos[maxn<<1]; // endpos数（一类子串的数量）
	int a[maxn];		
    int b[maxn<<1];
    int dp[maxn<<1];
//    int ans[maxn<<1];
//    ll d[maxn<<1];   //d[i]表示从状态i出发，不同的子串的数目,即不同的路径数
	void init() {	//初始化
		for(int i=1; i<=id; i++){ //常规初始化 
			link[i] = len[i] = 0;
			memset(next[i],0,sizeof(next[i]));
			endpos[i]=0;
			a[i]=0;
			b[i]=0;
		}
//		for(int i=1;i<=id;i++) {//非常规初始化 
//			d[i]=0;
//		}
		last = id = 1; //1表示root起始点 空集
	}
//SAM建图
	void add(int c) {     //插入字符，为字符ascll码值
		int x = ++id; //创建一个新结点x;
		len[x] = len[last] + 1; //  长度等于最后一个结点+1
		endpos[x] = 1;  //接受结点子串除后缀连接还需加一
		int p;  //第一个有C转移的结点;
		for (p = last; p && !next[p][c]; p = link[p])
			next[p][c] = x;//沿着后缀连接 将所有没有字符c转移的节点直接指向新结点
		if (!p){   //全部都没有c的转移 直接将新结点后缀连接到起点
			link[x] = 1;
		//	cnt[1]++;  
	    }
		else {
			int q = next[p][c];    //p通过c转移到的结点
			if (len[p] + 1 == len[q]){//pq是连续的
				link[x] = q;
			//	cnt[q]++; //将新结点后缀连接指向q即可,q结点的被后缀连接数+1
			} 
			else {
				int nq = ++id;   //不连续 需要复制一份q结点
				len[nq] = len[p] + 1;   //令nq与p连续
				link[nq] = link[q];   //因后面link[q]改变此处不加cnt
				memcpy(next[nq], next[q], sizeof(next[q]));  //复制q的信息给nq
				for (; p&&next[p][c] == q; p = link[p])
					next[p][c] = nq;    //沿着后缀连接 将所有通过c转移为q的改为nq
				link[q] = link[x] = nq; //将x和q后缀连接改为nq
				//cnt[nq] += 2; //  nq增加两个后缀连接	
			}
		}
		last = x;  //更新最后处理的结点	
	} 
	ll getSubNum() {	//求不相同子串数量
		ll ans = 0;
		for (int i = 2; i <= id; i++)
			ans += len[i]-len[link[i]];	//一状态子串数量等于len[i]-len[link[i]]
		return ans;
	} 
	void getTP(int Len){//对sam的节点按照len，从小到大排序重新标号，即给定节点的拓扑序
	    for(int i=1;i<=id;i++) a[len[i]]++;
		for(int i=1;i<=Len;i++) a[i]+=a[i-1];
		for(int i=1;i<=id;i++) b[a[len[i]]--]=i;
	}
	void getendpos(){//求每类子串的数量 ,即endpos集合的大小 
		for(int i=id;i>=1;i--){ //按拓扑序遍历 
			int e=b[i];
			endpos[link[e]]+=endpos[e];
		} 
	}
	void get_len_max(int Len){//求长度为i的出现次数最多的子串的出现次数 
		for(int i=1;i<=id;i++) dp[len[i]]=max(dp[len[i]],endpos[i]);
		for(int i=Len-1;i>=1;i--) dp[i]=max(dp[i],dp[i+1]);
		for(int i=1;i<=Len;i++) printf("%d\n",dp[i]);
	}
	/*
	void LCS1(char s[],int Len){//求两个串的最长公共子串
	    int ans=0,cnt=0;
	    int now=1;
	    char base='a';
	    for(int i=0;i<Len;i++){
	      	int c=s[i]-base;
	      	if(next[now][c]){
	      	    cnt++;
	      	    now=next[now][c];
			}
			else{
			  	while(now&&!next[now][c]) now=link[now];
			  	if(!now) cnt=0,now=1;
			  	else cnt=len[now]+1,now=next[now][c];
			}
			ans=max(ans,cnt);
		}
		printf("%d\n",ans);
	} 
	*/
	
	/*
	void init_ans(){
		for(int i=1;i<=id;i++) ans[i]=len[i];
	}
	void LCS2(char s[],int Len){     //求多个串的最长公共子串 
		for(int i=1;i<=id;i++) dp[i]=0;
		int cnt=0;
	    int now=1;
	    char base='a';
	    for(int i=0;i<Len;i++){
	      	int c=s[i]-base;
	      	if(next[now][c]){
	      	    cnt++;
	      	    now=next[now][c];
			}
			else{
			  	while(now&&!next[now][c]) now=link[now];
			  	if(!now) cnt=0,now=1;
			  	else cnt=len[now]+1,now=next[now][c];
			}
			dp[now]=max(dp[now],cnt);
		}
		for(int i=id;i>=1;i--){
			int e=b[i];
			dp[link[e]]=max(dp[link[e]],min(dp[e],len[link[e]]));
		}
		for(int i=1;i<=id;i++) ans[i]=min(ans[i],dp[i]);
	}
	void get_LCS2_ans(){
		int cnt=0;
		for(int i=1;i<=id;i++) cnt=max(cnt,ans[i]);
		printf("%d\n",cnt);
	}
	*/
	
	/*
	void solve1(){ //求出现次数为k的子串种数 
		ll ans=0;
		for(int i=1;i<=id;i++){
			if(endpos[i]==K){
				ans+=len[i]-len[link[i]];
			}
		}
		printf("%lld\n",ans);
	}
	 */
	 
	/*
	void solve1(){//求出现次数A<=K<=B的子串种数 
		for(int i=id;i>1;i--){
			int v=b[i];
			if(endpos[v]>=A&&endpos[v]<=B) d[v]++;
			for(int j=0;j<26;j++){
				if(next[v][j]) d[v]+=d[next[v][j]];
			}
		}
		ll ans=0;
		for(int i=0;i<26;i++){
			if(next[1][i]) ans+=d[next[1][i]];
		}
		printf("%lld\n",ans);
	}
	*/
	
	/*
	void solve2(){//求出现次数>=k的子串的最大长度 
		int ans=0;
		for(int i=1;i<=id;i++){
			if(endpos[i]>=K){
				ans=max(ans,len[i]);
			}
		}
		printf("%d\n",ans);
	}*/
	
} sam;
int main(){
    scanf("%s",s);
    int len=strlen(s);
    sam.init();
    for(int i=0;i<len;i++)
    sam.add(s[i]-'a');
    sam.getTP(len);
	sam.getendpos();
	sam.get_len_max(len);
	return 0;
}
```



### 8.PAM

```c++
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i = a; i <= b; i++)
#define per(i,a,b) for(int i = a; i >= b; i--)
const int N = 1e6+10;
using namespace std;

struct PAM{
    #define KIND 26
    int n,last,tot;
    int len[N],trie[N][KIND],fail[N],cnt[N],S[N],num[N];
    //len[i]: 节点i所代表的回文串长度, fail[i]: 当前回文串的最长回文后缀（不包括自身）
    //cnt[i]: 节点i所代表的回文串的个数, S[i]: 第i次添加的字符, num[i]: 以第i个字符为结尾的回文串个数
    //last: 上一个字符构成最长回文串的位置，方便下一个字符的插入
    //tot: 总结点个数 = 本质不同的回文串的个数+2, n: 插入字符的个数 
    int trans[N], g[N];
    int tot_2, mx2;
    //trans[i]: 第一个长度<=len[i]/2的最长回文后缀对应的节点-> 用于解决二倍回文问题
    //g[i]: 以i结尾的二倍回文个数
    // tot_2：二倍回文总数 mx2: 最长二倍回文
    int newnode(int l){
        rep(i,0,KIND-1) trie[tot][i] = 0;
        cnt[tot] = 0, len[tot] = l, num[tot] = 0;
        return tot++;
    }
    inline void init(){
        tot = n = last = 0, newnode(0), newnode(-1);
        S[0] = -1, fail[0] = 1;
        tot_2=0 ,mx2=0;
    }
    int get_fail(int x){ //获取fail指针
        while(S[n-len[x]-1] != S[n]) x = fail[x];
        return x;
    }
    inline int insert(int c){ //插入字符
        c -= 'a';
        S[++n] = c;
        int cur = get_fail(last);
        //在节点cur前的字符与当前字符相同，即构成一个回文串
        if(!trie[cur][c]){ //这个回文串没有出现过
            int now = newnode(len[cur]+2);
            fail[now] = trie[get_fail(fail[cur])][c];
            trie[cur][c] = now;
            num[now] = num[fail[now]]+1; //更新以当前字符为结尾的回文串的个数
            if(len[fail[now]]*2 <= len[now])trans[now] = fail[now];
            else {
                int t = trans[cur];//不需要从cur开始跑 相当于优化
                while((S[n-len[t]-1] != S[n]) || ((len[t]+2)*2 > len[now]))t=fail[t];
                trans[now]=trie[t][c];
            }
            g[now] = g[fail[now]] + (len[trans[now]]*2 == len[now]);
        }
        last = trie[cur][c];
        if(len[last] == len[trans[last]]*2 && len[trans[last]]%2==0)mx2=max(mx2, len[last]);
        //如果允许由2个奇数回文组成就不需要 len[trans[last]]%2==0 
        tot_2 += g[last];
        cnt[last]++; //更新当前回文串的个数
        return num[last]; //返回以当前字符结尾的回文串的个数
    }
    void count(){ //统计每个本质不同回文串的个数
        per(i,tot-1,0) cnt[fail[i]] += cnt[i];
    }
}pam;

signed main(){
    int n; cin>>n;
	pam.init();
	string s; cin>>s;
	for(auto c:s)pam.insert(c);

}
```



## 几何

### 俊杰板子

```c++
#include <bits/stdc++.h>
using namespace std;
#define ll long long
using point_t=long double;  //全局数据类型，可修改为 long long 等

constexpr point_t eps=1e-8;
constexpr long double PI=3.1415926535897932384l;

// 点与向量
template<typename T> struct point{
    T x,y;

    bool operator==(const point &a) const {return (abs(x-a.x)<=eps && abs(y-a.y)<=eps);}
    bool operator<(const point &a) const {if (abs(x-a.x)<=eps) return y<a.y-eps; return x<a.x-eps;}
    bool operator>(const point &a) const {return !(*this<a || *this==a);}
    point operator+(const point &a) const {return {x+a.x,y+a.y};}
    point operator-(const point &a) const {return {x-a.x,y-a.y};}
    point operator-() const {return {-x,-y};}
    point operator*(const T k) const {return {k*x,k*y};}
    point operator/(const T k) const {return {x/k,y/k};}
    T operator*(const point &a) const {return x*a.x+y*a.y;}  // 点积
    T operator^(const point &a) const {return x*a.y-y*a.x;}  // 叉积，注意优先级
    int toleft(const point &a) const {const auto t=(*this)^a; return (t>eps)-(t<-eps);}  // to-left 测试
    T len2() const {return (*this)*(*this);}  // 向量长度的平方
    T dis2(const point &a) const {return (a-(*this)).len2();}  // 两点距离的平方

    // 涉及浮点数
    long double len() const {return sqrtl(len2());}  // 向量长度
    long double dis(const point &a) const {return sqrtl(dis2(a));}  // 两点距离
    long double ang(const point &a) const {return acosl(max(-1.0l,min(1.0l,((*this)*a)/(len()*a.len()))));}  // 向量夹角
    point rot(const long double rad) const {return {x*cos(rad)-y*sin(rad),x*sin(rad)+y*cos(rad)};}  // 逆时针旋转（给定角度）
    point rot(const long double cosr,const long double sinr) const {return {x*cosr-y*sinr,x*sinr+y*cosr};}  // 逆时针旋转（给定角度的正弦与余弦）
};

using Point=point<point_t>;

// 极角排序
struct argcmp{
    bool operator()(const Point &a,const Point &b) const{
        const auto quad=[](const Point &a){
            if (a.y<-eps) return 1;
            if (a.y>eps) return 4;
            if (a.x<-eps) return 5;
            if (a.x>eps) return 3;
            return 2;
        };
        const int qa=quad(a),qb=quad(b);
        if (qa!=qb) return qa<qb;
        const auto t=a^b;
        // if (abs(t)<=eps) return a*a<b*b-eps;  // 不同长度的向量需要分开
        return t>eps;
    }
};

// 直线
template<typename T> struct line{
    point<T> p,v;  // p 为直线上一点，v 为方向向量

    bool operator==(const line &a) const {return v.toleft(a.v)==0 && v.toleft(p-a.p)==0;}
    int toleft(const point<T> &a) const {return v.toleft(a-p);}  // to-left 测试
    bool operator<(const line &a) const{  // 半平面交算法定义的排序
        if (abs(v^a.v)<=eps && v*a.v>=-eps) return toleft(a.p)==-1;
        return argcmp()(v,a.v);
    }

    // 涉及浮点数
    point<T> inter(const line &a) const {return p+v*((a.v^(p-a.p))/(v^a.v));}  // 直线交点
    long double dis(const point<T> &a) const {return abs(v^(a-p))/v.len();}  // 点到直线距离
    point<T> proj(const point<T> &a) const {return p+v*((v*(a-p))/(v*v));}  // 点在直线上的投影
};

using Line=line<point_t>;

//线段
template<typename T> struct segment{
    point<T> a,b;

    bool operator<(const segment &s) const {return make_pair(a,b)<make_pair(s.a,s.b);}

    // 判定性函数建议在整数域使用

    // 判断点是否在线段上
    // -1 点在线段端点 | 0 点不在线段上 | 1 点严格在线段上
    int is_on(const point<T> &p) const  {
        if (p==a || p==b) return -1;
        return (p-a).toleft(p-b)==0 && (p-a)*(p-b)<-eps;
    }

    // 判断线段直线是否相交
    // -1 直线经过线段端点 | 0 线段和直线不相交 | 1 线段和直线严格相交
    int is_inter(const line<T> &l) const{
        if (l.toleft(a)==0 || l.toleft(b)==0) return -1;
        return l.toleft(a)!=l.toleft(b);
    }
    
    // 判断两线段是否相交
    // -1 在某一线段端点处相交 | 0 两线段不相交 | 1 两线段严格相交
    int is_inter(const segment<T> &s) const{
        if (is_on(s.a) || is_on(s.b) || s.is_on(a) || s.is_on(b)) return -1;
        const line<T> l{a,b-a},ls{s.a,s.b-s.a};
        return l.toleft(s.a)*l.toleft(s.b)==-1 && ls.toleft(a)*ls.toleft(b)==-1;
    }

    // 点到线段距离
    long double dis(const point<T> &p) const{
        if ((p-a)*(b-a)<-eps || (p-b)*(a-b)<-eps) return min(p.dis(a),p.dis(b));
        const line<T> l{a,b-a};
        return l.dis(p);
    }

    // 两线段间距离
    long double dis(const segment<T> &s) const{
        if (is_inter(s)) return 0;
        return min({dis(s.a),dis(s.b),s.dis(a),s.dis(b)});
    }
};

using Segment=segment<point_t>;

// 多边形
template<typename T> struct polygon{
    vector<point<T>> p;  // 以逆时针顺序存储

    size_t nxt(const size_t i) const {return i==p.size()-1?0:i+1;}
    size_t pre(const size_t i) const {return i==0?p.size()-1:i-1;}
    
    // 回转数
    // 返回值第一项表示点是否在多边形边上
    // 对于狭义多边形，回转数为 0 表示点在多边形外，否则点在多边形内
    pair<bool,int> winding(const point<T> &a) const{
        int cnt=0;
        for (size_t i=0;i<p.size();i++)
        {
            const point<T> u=p[i],v=p[nxt(i)];
            if (abs((a-u)^(a-v))<=eps && (a-u)*(a-v)<=eps) return {true,0};
            if (abs(u.y-v.y)<=eps) continue;
            const Line uv={u,v-u};
            if (u.y<v.y-eps && uv.toleft(a)<=0) continue;
            if (u.y>v.y+eps && uv.toleft(a)>=0) continue;
            if (u.y<a.y-eps && v.y>=a.y-eps) cnt++;
            if (u.y>=a.y-eps && v.y<a.y-eps) cnt--;
        }
        return {false,cnt};
    }

    // 多边形面积的两倍
    // 可用于判断点的存储顺序是顺时针或逆时针
    T area() const{
        T sum=0;
        for (size_t i=0;i<p.size();i++) sum+=p[i]^p[nxt(i)];
        return sum;
    }

    // 多边形的周长
    long double circ() const{
        long double sum=0;
        for (size_t i=0;i<p.size();i++) sum+=p[i].dis(p[nxt(i)]);
        return sum;
    }
};

using Polygon=polygon<point_t>;

//凸多边形
template<typename T> struct convex: polygon<T>{
    // 闵可夫斯基和
    convex operator+(const convex &c) const  {
        const auto &p=this->p;
        vector<Segment> e1(p.size()),e2(c.p.size()),edge(p.size()+c.p.size());
        vector<point<T>> res; res.reserve(p.size()+c.p.size());
        const auto cmp=[](const Segment &u,const Segment &v) {return argcmp()(u.b-u.a,v.b-v.a);};
        for (size_t i=0;i<p.size();i++) e1[i]={p[i],p[this->nxt(i)]};
        for (size_t i=0;i<c.p.size();i++) e2[i]={c.p[i],c.p[c.nxt(i)]};
        rotate(e1.begin(),min_element(e1.begin(),e1.end(),cmp),e1.end());
        rotate(e2.begin(),min_element(e2.begin(),e2.end(),cmp),e2.end());
        merge(e1.begin(),e1.end(),e2.begin(),e2.end(),edge.begin(),cmp);
        const auto check=[](const vector<point<T>> &res,const point<T> &u){
            const auto back1=res.back(),back2=*prev(res.end(),2);
            return (back1-back2).toleft(u-back1)==0 && (back1-back2)*(u-back1)>=-eps;
        };
        auto u=e1[0].a+e2[0].a;
        for (const auto &v:edge){
            while (res.size()>1 && check(res,u)) res.pop_back();
            res.push_back(u);
            u=u+v.b-v.a;
        }
        if (res.size()>1 && check(res,res[0])) res.pop_back();
        return {res};
    }

    // 旋转卡壳
    // func 为更新答案的函数，可以根据题目调整位置
    template<typename F> void rotcaliper(const F &func) const{
        const auto &p=this->p;
        const auto area=[](const point<T> &u,const point<T> &v,const point<T> &w){return (w-u)^(w-v);};
        for (size_t i=0,j=1;i<p.size();i++){
            const auto nxti=this->nxt(i);
            func(p[i],p[nxti],p[j]);
            while (area(p[this->nxt(j)],p[i],p[nxti])>=area(p[j],p[i],p[nxti])){
                j=this->nxt(j);
                func(p[i],p[nxti],p[j]);
            }
        }
    }

    // 凸多边形的直径的平方
    T diameter2() const{
        const auto &p=this->p;
        if (p.size()==1) return 0;
        if (p.size()==2) return p[0].dis2(p[1]);
        T ans=0;
        auto func=[&](const point<T> &u,const point<T> &v,const point<T> &w){ans=max({ans,w.dis2(u),w.dis2(v)});};
        rotcaliper(func);
        return ans;
    }
    
    // 判断点是否在凸多边形内
    // 复杂度 O(logn)
    // -1 点在多边形边上 | 0 点在多边形外 | 1 点在多边形内
    int is_in(const point<T> &a) const{
        const auto &p=this->p;
        if (p.size()==1) return a==p[0]?-1:0;
        if (p.size()==2) return segment<T>{p[0],p[1]}.is_on(a)?-1:0; 
        if (a==p[0]) return -1;
        if ((p[1]-p[0]).toleft(a-p[0])==-1 || (p.back()-p[0]).toleft(a-p[0])==1) return 0;
        const auto cmp=[&](const Point &u,const Point &v){return (u-p[0]).toleft(v-p[0])==1;};
        const size_t i=lower_bound(p.begin()+1,p.end(),a,cmp)-p.begin();
        if (i==1) return segment<T>{p[0],p[i]}.is_on(a)?-1:0;
        if (i==p.size()-1 && segment<T>{p[0],p[i]}.is_on(a)) return -1;
        if (segment<T>{p[i-1],p[i]}.is_on(a)) return -1;
        return (p[i]-p[i-1]).toleft(a-p[i-1])>0;
    }

    // 凸多边形关于某一方向的极点
    // 复杂度 O(logn)
    // 参考资料：https://codeforces.com/blog/entry/48868
    template<typename F> size_t extreme(const F &dir) const{
        const auto &p=this->p;
        const auto check=[&](const size_t i){return dir(p[i]).toleft(p[this->nxt(i)]-p[i])>=0;};
        const auto dir0=dir(p[0]); const auto check0=check(0);
        if (!check0 && check(p.size()-1)) return 0;
        const auto cmp=[&](const Point &v){
            const size_t vi=&v-p.data();
            if (vi==0) return 1;
            const auto checkv=check(vi);
            const auto t=dir0.toleft(v-p[0]);
            if (vi==1 && checkv==check0 && t==0) return 1;
            return checkv^(checkv==check0 && t<=0);
        };
        return partition_point(p.begin(),p.end(),cmp)-p.begin();
    }

    // 过凸多边形外一点求凸多边形的切线，返回切点下标
    // 复杂度 O(logn)
    // 必须保证点在多边形外
    pair<size_t,size_t> tangent(const point<T> &a) const{
        const size_t i=extreme([&](const point<T> &u){return u-a;});
        const size_t j=extreme([&](const point<T> &u){return a-u;});
        return {i,j};
    }

    // 求平行于给定直线的凸多边形的切线，返回切点下标
    // 复杂度 O(logn)
    pair<size_t,size_t> tangent(const line<T> &a) const{
        const size_t i=extreme([&](...){return a.v;});
        const size_t j=extreme([&](...){return -a.v;});
        return {i,j};
    }
};

using Convex=convex<point_t>;

// 圆
struct Circle
{
    Point c;
    long double r;

    bool operator==(const Circle &a) const {return c==a.c && abs(r-a.r)<=eps;}
    long double circ() const {return 2*PI*r;}  // 周长
    long double area() const {return PI*r*r;}  // 面积

    // 点与圆的关系
    // -1 圆上 | 0 圆外 | 1 圆内
    int is_in(const Point &p) const {const long double d=p.dis(c); return abs(d-r)<=eps?-1:d<r-eps;}

    // 直线与圆关系
    // 0 相离 | 1 相切 | 2 相交
    int relation(const Line &l) const
    {
        const long double d=l.dis(c);
        if (d>r+eps) return 0;
        if (abs(d-r)<=eps) return 1;
        return 2;
    }

    // 圆与圆关系
    // -1 相同 | 0 相离 | 1 外切 | 2 相交 | 3 内切 | 4 内含
    int relation(const Circle &a) const
    {
        if (*this==a) return -1;
        const long double d=c.dis(a.c);
        if (d>r+a.r+eps) return 0;
        if (abs(d-r-a.r)<=eps) return 1;
        if (abs(d-abs(r-a.r))<=eps) return 3;
        if (d<abs(r-a.r)-eps) return 4;
        return 2;
    }

    // 直线与圆的交点
    vector<Point> inter(const Line &l) const
    {
        const long double d=l.dis(c);
        const Point p=l.proj(c);
        const int t=relation(l);
        if (t==0) return vector<Point>();
        if (t==1) return vector<Point>{p};
        const long double k=sqrt(r*r-d*d);
        return vector<Point>{p-(l.v/l.v.len())*k,p+(l.v/l.v.len())*k};
    }

    // 圆与圆交点
    vector<Point> inter(const Circle &a) const
    {
        const long double d=c.dis(a.c);
        const int t=relation(a);
        if (t==-1 || t==0 || t==4) return vector<Point>();
        Point e=a.c-c; e=e/e.len()*r;
        if (t==1 || t==3) 
        {
            if (r*r+d*d-a.r*a.r>=-eps) return vector<Point>{c+e};
            return vector<Point>{c-e};
        }
        const long double costh=(r*r+d*d-a.r*a.r)/(2*r*d),sinth=sqrt(1-costh*costh);
        return vector<Point>{c+e.rot(costh,-sinth),c+e.rot(costh,sinth)};
    }

    // 圆与圆交面积
    long double inter_area(const Circle &a) const
    {
        const long double d=c.dis(a.c);
        const int t=relation(a);
        if (t==-1) return area();
        if (t<2) return 0;
        if (t>2) return min(area(),a.area());
        const long double costh1=(r*r+d*d-a.r*a.r)/(2*r*d),costh2=(a.r*a.r+d*d-r*r)/(2*a.r*d);
        const long double sinth1=sqrt(1-costh1*costh1),sinth2=sqrt(1-costh2*costh2);
        const long double th1=acos(costh1),th2=acos(costh2);
        return r*r*(th1-costh1*sinth1)+a.r*a.r*(th2-costh2*sinth2);
    }

    // 过圆外一点圆的切线
    vector<Line> tangent(const Point &a) const
    {
        const int t=is_in(a);
        if (t==1) return vector<Line>();
        if (t==-1)
        {
            const Point v={-(a-c).y,(a-c).x};
            return vector<Line>{{a,v}};
        }
        Point e=a-c; e=e/e.len()*r;
        const long double costh=r/c.dis(a),sinth=sqrt(1-costh*costh);
        const Point t1=c+e.rot(costh,-sinth),t2=c+e.rot(costh,sinth);
        return vector<Line>{{a,t1-a},{a,t2-a}};
    }

    // 两圆的公切线
    vector<Line> tangent(const Circle &a) const
    {
        const int t=relation(a);
        vector<Line> lines;
        if (t==-1 || t==4) return lines;
        if (t==1 || t==3)
        {
            const Point p=inter(a)[0],v={-(a.c-c).y,(a.c-c).x};
            lines.push_back({p,v});
        }
        const long double d=c.dis(a.c);
        const Point e=(a.c-c)/(a.c-c).len();
        if (t<=2)
        {
            const long double costh=(r-a.r)/d,sinth=sqrt(1-costh*costh);
            const Point d1=e.rot(costh,-sinth),d2=e.rot(costh,sinth);
            const Point u1=c+d1*r,u2=c+d2*r,v1=a.c+d1*a.r,v2=a.c+d2*a.r;
            lines.push_back({u1,v1-u1}); lines.push_back({u2,v2-u2});
        }
        if (t==0)
        {
            const long double costh=(r+a.r)/d,sinth=sqrt(1-costh*costh);
            const Point d1=e.rot(costh,-sinth),d2=e.rot(costh,sinth);
            const Point u1=c+d1*r,u2=c+d2*r,v1=a.c-d1*a.r,v2=a.c-d2*a.r;
            lines.push_back({u1,v1-u1}); lines.push_back({u2,v2-u2});
        }
        return lines;
    }

    // 圆的反演
    tuple<int,Circle,Line> inverse(const Line &l) const
    {
        const Circle null_c={{0.0,0.0},0.0};
        const Line null_l={{0.0,0.0},{0.0,0.0}};
        if (l.toleft(c)==0) return {2,null_c,l};
        const Point v=l.toleft(c)==1?Point{l.v.y,-l.v.x}:Point{-l.v.y,l.v.x};
        const long double d=r*r/l.dis(c);
        const Point p=c+v/v.len()*d;
        return {1,{(c+p)/2,d/2},null_l};
    }
    
    tuple<int,Circle,Line> inverse(const Circle &a) const
    {
        const Circle null_c={{0.0,0.0},0.0};
        const Line null_l={{0.0,0.0},{0.0,0.0}};
        const Point v=a.c-c;
        if (a.is_in(c)==-1)
        {
            const long double d=r*r/(a.r+a.r);
            const Point p=c+v/v.len()*d;
            return {2,null_c,{p,{-v.y,v.x}}};
        }
        if (c==a.c) return {1,{c,r*r/a.r},null_l};
        const long double d1=r*r/(c.dis(a.c)-a.r),d2=r*r/(c.dis(a.c)+a.r);
        const Point p=c+v/v.len()*d1,q=c+v/v.len()*d2;
        return {1,{(p+q)/2,p.dis(q)/2},null_l};
    }
};

// 圆与多边形面积交
long double area_inter(const Circle &circ,const Polygon &poly)
{
    const auto cal=[](const Circle &circ,const Point &a,const Point &b)
    {
        if ((a-circ.c).toleft(b-circ.c)==0) return 0.0l;
        const auto ina=circ.is_in(a),inb=circ.is_in(b);
        const Line ab={a,b-a};
        if (ina && inb) return ((a-circ.c)^(b-circ.c))/2;
        if (ina && !inb)
        {
            const auto t=circ.inter(ab);
            const Point p=t.size()==1?t[0]:t[1];
            const long double ans=((a-circ.c)^(p-circ.c))/2;
            const long double th=(p-circ.c).ang(b-circ.c);
            const long double d=circ.r*circ.r*th/2;
            if ((a-circ.c).toleft(b-circ.c)==1) return ans+d;
            return ans-d;
        }
        if (!ina && inb)
        {
            const Point p=circ.inter(ab)[0];
            const long double ans=((p-circ.c)^(b-circ.c))/2;
            const long double th=(a-circ.c).ang(p-circ.c);
            const long double d=circ.r*circ.r*th/2;
            if ((a-circ.c).toleft(b-circ.c)==1) return ans+d;
            return ans-d;
        }
        const auto p=circ.inter(ab);
        if (p.size()==2 && Segment{a,b}.dis(circ.c)<=circ.r+eps)
        {
            const long double ans=((p[0]-circ.c)^(p[1]-circ.c))/2;
            const long double th1=(a-circ.c).ang(p[0]-circ.c),th2=(b-circ.c).ang(p[1]-circ.c);
            const long double d1=circ.r*circ.r*th1/2,d2=circ.r*circ.r*th2/2;
            if ((a-circ.c).toleft(b-circ.c)==1) return ans+d1+d2;
            return ans-d1-d2;
        }
        const long double th=(a-circ.c).ang(b-circ.c);
        if ((a-circ.c).toleft(b-circ.c)==1) return circ.r*circ.r*th/2;
        return -circ.r*circ.r*th/2;
    };

    long double ans=0;
    for (size_t i=0;i<poly.p.size();i++)
    {
        const Point a=poly.p[i],b=poly.p[poly.nxt(i)];
        ans+=cal(circ,a,b);
    }
    return ans;
}

// 点集的凸包
// Andrew 算法，复杂度 O(nlogn)
Convex convexhull(vector<Point> p)
{
    vector<Point> st;
    if (p.empty()) return Convex{st};
    sort(p.begin(),p.end());
    const auto check=[](const vector<Point> &st,const Point &u)
    {
        const auto back1=st.back(),back2=*prev(st.end(),2);
        return (back1-back2).toleft(u-back1)<=0;
    };
    for (const Point &u:p)
    {
        while (st.size()>1 && check(st,u)) st.pop_back();
        st.push_back(u);
    }
    size_t k=st.size();
    p.pop_back(); reverse(p.begin(),p.end());
    for (const Point &u:p)
    {
        while (st.size()>k && check(st,u)) st.pop_back();
        st.push_back(u);
    }
    st.pop_back();
    return Convex{st};
}

// 半平面交
// 排序增量法，复杂度 O(nlogn)
// 输入与返回值都是用直线表示的半平面集合
vector<Line> halfinter(vector<Line> l, const point_t lim=1e9)
{
    const auto check=[](const Line &a,const Line &b,const Line &c){return a.toleft(b.inter(c))<0;};
    // 无精度误差的方法，但注意取值范围会扩大到三次方
    /*const auto check=[](const Line &a,const Line &b,const Line &c)
    {
        const Point p=a.v*(b.v^c.v),q=b.p*(b.v^c.v)+b.v*(c.v^(b.p-c.p))-a.p*(b.v^c.v);
        return p.toleft(q)<0;
    };*/
    l.push_back({{-lim,0},{0,-1}}); l.push_back({{0,-lim},{1,0}});
    l.push_back({{lim,0},{0,1}}); l.push_back({{0,lim},{-1,0}});
    sort(l.begin(),l.end());
    deque<Line> q;
    for (size_t i=0;i<l.size();i++)
    {
        if (i>0 && l[i-1].v.toleft(l[i].v)==0 && l[i-1].v*l[i].v>eps) continue;
        while (q.size()>1 && check(l[i],q.back(),q[q.size()-2])) q.pop_back();
        while (q.size()>1 && check(l[i],q[0],q[1])) q.pop_front();
        if (!q.empty() && q.back().v.toleft(l[i].v)<=0) return vector<Line>();
        q.push_back(l[i]);
    }
    while (q.size()>1 && check(q[0],q.back(),q[q.size()-2])) q.pop_back();
    while (q.size()>1 && check(q.back(),q[0],q[1])) q.pop_front();
    return vector<Line>(q.begin(),q.end());
}

// 点集形成的最小最大三角形
// 极角序扫描线，复杂度 O(n^2logn)
// 最大三角形问题可以使用凸包与旋转卡壳做到 O(n^2)
pair<point_t,point_t> minmax_triangle(const vector<Point> &vec)
{
    if (vec.size()<=2) return {0,0};
    vector<pair<int,int>> evt;
    evt.reserve(vec.size()*vec.size());
    point_t maxans=0,minans=numeric_limits<point_t>::max();
    for (size_t i=0;i<vec.size();i++)
    {
        for (size_t j=0;j<vec.size();j++)
        {
            if (i==j) continue;
            if (vec[i]==vec[j]) minans=0;
            else evt.push_back({i,j});
        }
    }
    sort(evt.begin(),evt.end(),[&](const pair<int,int> &u,const pair<int,int> &v)
    {
        const Point du=vec[u.second]-vec[u.first],dv=vec[v.second]-vec[v.first];
        return argcmp()({du.y,-du.x},{dv.y,-dv.x});
    });
    vector<size_t> vx(vec.size()),pos(vec.size());
    for (size_t i=0;i<vec.size();i++) vx[i]=i;
    sort(vx.begin(),vx.end(),[&](int x,int y){return vec[x]<vec[y];});
    for (size_t i=0;i<vx.size();i++) pos[vx[i]]=i;
    for (auto [u,v]:evt)
    {
        const size_t i=pos[u],j=pos[v];
        const size_t l=min(i,j),r=max(i,j);
        const Point vecu=vec[u],vecv=vec[v];
        if (l>0) minans=min(minans,abs((vec[vx[l-1]]-vecu)^(vec[vx[l-1]]-vecv)));
        if (r<vx.size()-1) minans=min(minans,abs((vec[vx[r+1]]-vecu)^(vec[vx[r+1]]-vecv)));
        maxans=max({maxans,abs((vec[vx[0]]-vecu)^(vec[vx[0]]-vecv)),abs((vec[vx.back()]-vecu)^(vec[vx.back()]-vecv))});
        if (i<j) swap(vx[i],vx[j]),pos[u]=j,pos[v]=i;
    }
    return {minans,maxans};
}

// 判断多条线段是否有交点
// 扫描线，复杂度 O(nlogn)
bool segs_inter(const vector<Segment> &segs)
{
    if (segs.empty()) return false;
    using seq_t=tuple<point_t,int,Segment>;
    const auto seqcmp=[](const seq_t &u, const seq_t &v)
    {
        const auto [u0,u1,u2]=u;
        const auto [v0,v1,v2]=v;
        if (abs(u0-v0)<=eps) return make_pair(u1,u2)<make_pair(v1,v2);
        return u0<v0-eps;
    };
    vector<seq_t> seq;
    for (auto seg:segs)
    {
        if (seg.a.x>seg.b.x+eps) swap(seg.a,seg.b);
        seq.push_back({seg.a.x,0,seg});
        seq.push_back({seg.b.x,1,seg});
    }
    sort(seq.begin(),seq.end(),seqcmp);
    point_t x_now;
    auto cmp=[&](const Segment &u, const Segment &v)
    {
        if (abs(u.a.x-u.b.x)<=eps || abs(v.a.x-v.b.x)<=eps) return u.a.y<v.a.y-eps;
        return ((x_now-u.a.x)*(u.b.y-u.a.y)+u.a.y*(u.b.x-u.a.x))*(v.b.x-v.a.x)<((x_now-v.a.x)*(v.b.y-v.a.y)+v.a.y*(v.b.x-v.a.x))*(u.b.x-u.a.x)-eps;
    };
    multiset<Segment,decltype(cmp)> s{cmp};
    for (const auto [x,o,seg]:seq)
    {
        x_now=x;
        const auto it=s.lower_bound(seg);
        if (o==0)
        {
            if (it!=s.end() && seg.is_inter(*it)) return true;
            if (it!=s.begin() && seg.is_inter(*prev(it))) return true;
            s.insert(seg);
        }
        else
        {
            if (next(it)!=s.end() && it!=s.begin() && (*prev(it)).is_inter(*next(it))) return true;
            s.erase(it);
        }
    }
    return false;
}

// 多边形面积并
// 轮廓积分，复杂度 O(n^2logn)，n为边数
// ans[i] 表示被至少覆盖了 i+1 次的区域的面积
vector<long double> area_union(const vector<Polygon> &polys)
{
    const size_t siz=polys.size();
    vector<vector<pair<Point,Point>>> segs(siz);
    const auto check=[](const Point &u,const Segment &e){return !((u<e.a && u<e.b) || (u>e.a && u>e.b));};

    auto cut_edge=[&](const Segment &e,const size_t i)
    {
        const Line le{e.a,e.b-e.a};
        vector<pair<Point,int>> evt;
        evt.push_back({e.a,0}); evt.push_back({e.b,0});
        for (size_t j=0;j<polys.size();j++)
        {
            if (i==j) continue;
            const auto &pj=polys[j];
            for (size_t k=0;k<pj.p.size();k++)
            {
                const Segment s={pj.p[k],pj.p[pj.nxt(k)]};
                if (le.toleft(s.a)==0 && le.toleft(s.b)==0)
                {
                    evt.push_back({s.a,0});
                    evt.push_back({s.b,0});
                }
                else if (s.is_inter(le))
                {
                    const Line ls{s.a,s.b-s.a};
                    const Point u=le.inter(ls);
                    if (le.toleft(s.a)<0 && le.toleft(s.b)>=0) evt.push_back({u,-1});
                    else if (le.toleft(s.a)>=0 && le.toleft(s.b)<0) evt.push_back({u,1});
                }
            }
        }
        sort(evt.begin(),evt.end());
        if (e.a>e.b) reverse(evt.begin(),evt.end());
        int sum=0;
        for (size_t i=0;i<evt.size();i++)
        {
            sum+=evt[i].second;
            const Point u=evt[i].first,v=evt[i+1].first;
            if (!(u==v) && check(u,e) && check(v,e)) segs[sum].push_back({u,v});
            if (v==e.b) break;
        }
    };
    
    for (size_t i=0;i<polys.size();i++)
    {
        const auto &pi=polys[i];
        for (size_t k=0;k<pi.p.size();k++)
        {
            const Segment ei={pi.p[k],pi.p[pi.nxt(k)]};
            cut_edge(ei,i);
        }
    }
    vector<long double> ans(siz);
    for (size_t i=0;i<siz;i++)
    {
        long double sum=0;
        sort(segs[i].begin(),segs[i].end());
        int cnt=0;
        for (size_t j=0;j<segs[i].size();j++)
        {
            if (j>0 && segs[i][j]==segs[i][j-1]) segs[i+(++cnt)].push_back(segs[i][j]);
            else cnt=0,sum+=segs[i][j].first^segs[i][j].second;
        }
        ans[i]=sum/2;
    }
    return ans;
}

// 圆面积并
// 轮廓积分，复杂度 O(n^2logn)
// ans[i] 表示被至少覆盖了 i+1 次的区域的面积
vector<long double> area_union(const vector<Circle> &circs)
{
    const size_t siz=circs.size();
    using arc_t=tuple<Point,long double,long double,long double>;
    vector<vector<arc_t>> arcs(siz);
    const auto eq=[](const arc_t &u,const arc_t &v)
    {
        const auto [u1,u2,u3,u4]=u;
        const auto [v1,v2,v3,v4]=v;
        return u1==v1 && abs(u2-v2)<=eps && abs(u3-v3)<=eps && abs(u4-v4)<=eps;
    };

    auto cut_circ=[&](const Circle &ci,const size_t i)
    {
        vector<pair<long double,int>> evt;
        evt.push_back({-PI,0}); evt.push_back({PI,0});
        int init=0;
        for (size_t j=0;j<circs.size();j++)
        {
            if (i==j) continue;
            const Circle &cj=circs[j];
            if (ci.r<cj.r-eps && ci.relation(cj)>=3) init++;
            const auto inters=ci.inter(cj);
            if (inters.size()==1) evt.push_back({atan2l((inters[0]-ci.c).y,(inters[0]-ci.c).x),0});
            if (inters.size()==2)
            {
                const Point dl=inters[0]-ci.c,dr=inters[1]-ci.c;
                long double argl=atan2l(dl.y,dl.x),argr=atan2l(dr.y,dr.x);
                if (abs(argl+PI)<=eps) argl=PI;
                if (abs(argr+PI)<=eps) argr=PI;
                if (argl>argr+eps)
                {
                    evt.push_back({argl,1}); evt.push_back({PI,-1});
                    evt.push_back({-PI,1}); evt.push_back({argr,-1});
                }
                else
                {
                    evt.push_back({argl,1});
                    evt.push_back({argr,-1});
                }
            }
        }
        sort(evt.begin(),evt.end());
        int sum=init;
        for (size_t i=0;i<evt.size();i++)
        {
            sum+=evt[i].second;
            if (abs(evt[i].first-evt[i+1].first)>eps) arcs[sum].push_back({ci.c,ci.r,evt[i].first,evt[i+1].first});
            if (abs(evt[i+1].first-PI)<=eps) break;
        }
    };

    const auto oint=[](const arc_t &arc)
    {
        const auto [cc,cr,l,r]=arc;
        if (abs(r-l-PI-PI)<=eps) return 2.0l*PI*cr*cr;
        return cr*cr*(r-l)+cc.x*cr*(sin(r)-sin(l))-cc.y*cr*(cos(r)-cos(l));
    };

    for (size_t i=0;i<circs.size();i++)
    {
        const auto &ci=circs[i];
        cut_circ(ci,i);
    }
    vector<long double> ans(siz);
    for (size_t i=0;i<siz;i++)
    {
        long double sum=0;
        sort(arcs[i].begin(),arcs[i].end());
        int cnt=0;
        for (size_t j=0;j<arcs[i].size();j++)
        {
            if (j>0 && eq(arcs[i][j],arcs[i][j-1])) arcs[i+(++cnt)].push_back(arcs[i][j]);
            else cnt=0,sum+=oint(arcs[i][j]);
        }
        ans[i]=sum/2;
    }
    return ans;
}

```



### 模板

```c++
typedef double db;
const db EPS = 1e-9;
  
inline int sign(db a) { return a < -EPS ? -1 : a > EPS; }
  
inline int cmp(db a, db b){ return sign(a-b); }
  
struct P {
	db x, y;
	P() {}
	P(db _x, db _y) : x(_x), y(_y) {}  //点的加减乘除基本运算
	P operator+(P p) { return {x + p.x, y + p.y}; }
	P operator-(P p) { return {x - p.x, y - p.y}; }
	P operator*(db d) { return {x * d, y * d}; }
	P operator/(db d) { return {x / d, y / d}; }

	bool operator<(P p) const {   // 先比较x大小，再比较y 返回小的
		int c = cmp(x, p.x);
		if (c) return c == -1;
		return cmp(y, p.y) == -1;
	}

	bool operator==(P o) const{
		return cmp(x,o.x) == 0 && cmp(y,o.y) == 0;
	}

	db dot(P p) { return x * p.x + y * p.y; } //点积 正为角度<90 0为等于90 负为>90
	db det(P p) { return x * p.y - y * p.x; } //叉积 正为逆时针方向
	 
	db distTo(P p) { return (*this-p).abs(); } //求点到点的距离
	db alpha() { return atan2(y, x); } //求极角
	void read() { cin>>x>>y; }
	void write() {cout<<"("<<x<<","<<y<<")"<<endl;}
	db abs() { return sqrt(abs2());} // 求两点距离
	db abs2() { return x * x + y * y; } 
	P rot90() { return P(-y,x);} //旋转 90度
	P unit() { return *this/abs(); }//
	int quad() const { return sign(y) == 1 || (sign(y) == 0 && sign(x) >= 0); }
	P rot(db an){ return {x*cos(an) - y*sin(an),x*sin(an) + y*cos(an)}; }
};

#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))//(p1p2 叉乘 p1p3)
#define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))//0是三点共线 1是p1->p2->p3 是逆时针 ，-1则是顺时针
 
// 直线 p1p2, q1q2 是否恰有一个交点 无则平行
bool chkLL(P p1, P p2, P q1, P q2) {
	db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);
	return sign(a1+a2) != 0;
}

// 求直线 p1p2, q1q2 的交点	
P isLL(P p1, P p2, P q1, P q2) {
	db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);
	return (p1 * a2 + p2 * a1) / (a1 + a2);
}

// 判断区间 [l1, r1], [l2, r2] 是否相交
bool intersect(db l1,db r1,db l2,db r2){
	if (l1>r1) swap(l1,r1); if (l2>r2) swap(l2,r2); 
	return !( cmp(r1,l2) == -1 || cmp(r2,l1) == -1 );
}

// 线段 p1p2, q1q2 相交
bool isSS(P p1, P p2, P q1, P q2){
	return intersect(p1.x,p2.x,q1.x,q2.x) && intersect(p1.y,p2.y,q1.y,q2.y) && 
	crossOp(p1,p2,q1) * crossOp(p1,p2,q2) <= 0 && crossOp(q1,q2,p1)
			* crossOp(q1,q2,p2) <= 0;
}

// 线段 p1p2, q1q2 严格相交  (不交在端点)
bool isSS_strict(P p1, P p2, P q1, P q2){
	return crossOp(p1,p2,q1) * crossOp(p1,p2,q2) < 0 && crossOp(q1,q2,p1)
			* crossOp(q1,q2,p2) < 0;
}

// m 在 a 和 b 之间
bool isMiddle(db a, db m, db b) {
	/*if (a > b) swap(a, b);
	return cmp(a, m) <= 0 && cmp(m, b) <= 0;*/
	return sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);
}

bool isMiddle(P a, P m, P b) {
	return isMiddle(a.x, m.x, b.x) && isMiddle(a.y, m.y, b.y);
}

// 点 p 在线段 p1p2 上 
bool onSeg(P p1, P p2, P q){ //可能有精度问题
	return crossOp(p1,p2,q) == 0 && isMiddle(p1, q, p2);
}
// q1q2 和 p1p2 的交点 在 p1p2 上？确定的时候不需要crossOp(p1,p2,q) == 0

// 点 p 严格在 p1p2 上
bool onSeg_strict(P p1, P p2, P q){
	return crossOp(p1,p2,q) == 0 && sign((q-p1).dot(p1-p2)) * sign((q-p2).dot(p1-p2)) < 0;
}

// 求 q 到 直线p1p2 的投影（垂足） ⚠️ : p1 != p2
P proj(P p1, P p2, P q) {
	P dir = p2 - p1;
	return p1 + dir * (dir.dot(q - p1) / dir.abs2());
}

// 求 q 以 直线p1p2 为轴的反射
P reflect(P p1, P p2, P q){
	return proj(p1,p2,q) * 2 - q;
}

// 求 q 到 线段p1p2 的最小距离
db nearest(P p1, P p2, P q){
	if (p1 == p2) return p1.distTo(q);
	P h = proj(p1,p2,q);
	if(isMiddle(p1,h,p2))
		return q.distTo(h);
	return min(p1.distTo(q),p2.distTo(q));
}

// 求 线段p1p2 与 线段q1q2 的距离
db disSS(P p1, P p2, P q1, P q2){
	if(isSS(p1,p2,q1,q2)) return 0;
	return min(min(nearest(p1,p2,q1),nearest(p1,p2,q2)), min(nearest(q1,q2,p1),nearest(q1,q2,p2)));
}

// 极角排序

// sort(p, p + n, [&](P a, P b) {
// 	int qa = a.quad(), qb = b.quad();
// 	if (qa != qb) return qa < qb;
// 	else return sign(a.det(b)) > 0;
// }); 
例题:
给你 n 个点，任选三个点组成三角形，问锐角三角形个数。
P p[N];
void solve(){
    ll n;cin>>n;
    FOR(i,1,n)cin>>p[i].x>>p[i].y;
    ll res=n*(n-1)*(n-2)/6;
    FOR(i,1,n){
        vector<P>vec;
        FOR(j,1,n){
            if(i!=j){
                vec.push_back(p[j]-p[i]);
            }
        }
        sort(vec.begin(),vec.end(),[&](P a,P b){
            ll qa=a.quad(),qb=b.quad();
            if(qa!=qb)return qa<qb;
            else return sign(a.det(b))>0;
        });
        ll m=vec.size();
        for(int j=0;j<m;j++)vec.push_back(vec[j]);
        ll l=-1,r=-1;
        for(ll j=0;j<m;j++){
            l=max(l,j+1);r=max(r,j+1);
            auto check1=[&](P a,P b,ll idl){
                if(vec[j].dot(vec[l])>0){
                    auto d=vec[j].det(vec[l]);
                    if(d!=0)return d>0;
                    return idl<m;
                }
                return false;
            };
            while(l<j+m&&check1(vec[j],vec[l],l))l++;
            auto check2=[&](P a,P b,ll idr){
                auto d=a.det(b);
                if(d!=0)return d>0;
                return idr<m;
            };
            while(r<j+m&&check2(vec[j],vec[r],r))r++;
            res-=r-l;
        }
    }
    cout<<res<<endl;
}
```





### 多边形模板

```c++
#define rep(i, a, n) for (int i = a; i < n; i++)
db area(vector<P> ps){
	db ret = 0; rep(i,0,ps.size()) ret += ps[i].det(ps[(i+1)%ps.size()]); 
	return ret/2;
}
  
int contain(vector<P> ps, P p){ //2:inside,1:on_seg,0:outside  判断点包含
	int n = ps.size(), ret = 0; 
	rep(i,0,n){
		P u=ps[i],v=ps[(i+1)%n];
		if(onSeg(u,v,p)) return 1;
		if(cmp(u.y,v.y)<=0) swap(u,v);
		if(cmp(p.y,u.y) > 0 || cmp(p.y,v.y) <= 0) continue;
		ret ^= crossOp(p,u,v) > 0;
	}
	return ret*2;
}
  
vector<P> convexHull(vector<P> ps) { //创建凸包
	int n = ps.size(); if(n <= 1) return ps;
	sort(ps.begin(), ps.end());
	vector<P> qs(n * 2); int k = 0;
	for (int i = 0; i < n; qs[k++] = ps[i++]) 
		while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;
	for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])
		while (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;
	qs.resize(k - 1);
	return qs;
}
  
vector<P> convexHullNonStrict(vector<P> ps) { //严格的凸包，就是上面的基础上去重
	//caution: need to unique the Ps first
	int n = ps.size(); if(n <= 1) return ps;
	sort(ps.begin(), ps.end());
	vector<P> qs(n * 2); int k = 0;
	for (int i = 0; i < n; qs[k++] = ps[i++]) 
		while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0) --k;
	for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])
		while (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0) --k;
	qs.resize(k - 1);
	return qs;
}
  
db convexDiameter(vector<P> ps){// 找凸包最长直径
	int n = ps.size(); if(n <= 1) return 0;
	int is = 0, js = 0; rep(k,1,n) is = ps[k]<ps[is]?k:is, js = ps[js] < ps[k]?k:js;
	int i = is, j = js;
	db ret = ps[i].distTo(ps[j]);
	do{
		if((ps[(i+1)%n]-ps[i]).det(ps[(j+1)%n]-ps[j]) >= 0)
			(++j)%=n;
		else
			(++i)%=n;
		ret = max(ret,ps[i].distTo(ps[j]));
	}while(i!=is || j!=js);
	return ret;
}
  
vector<P> convexCut(const vector<P>&ps, P q1, P q2) {// [q1,q2]这条直线切割凸包
	vector<P> qs;
	int n = ps.size();
	rep(i,0,n){
		P p1 = ps[i], p2 = ps[(i+1)%n];
		int d1 = crossOp(q1,q2,p1), d2 = crossOp(q1,q2,p2);
		if(d1 >= 0) qs.push_back(p1);
		if(d1 * d2 < 0) qs.push_back(isLL(p1,p2,q1,q2));
	}
	return qs;
}
```

### 1.维护凸包

```c++
 // 维护多条线段，求x处的最大值. 最小值就让交点尽可能左边？
struct line {
    int k, b;
    line() {}
    line(int k, int b) : k(k), b(b) {}

    double intersect(line l) {
        //交点
        double db = l.b - b;
        double dk = k - l.k;
        return db / dk;
    }
 
    int operator () (int x) {
        return k * x + b;
    }
};
 
struct CHT {
    vector<double> x;
    vector<line> L;
 
    void init(line l) {//记得初始先插入一条不影响的直线
        x.push_back(-1e18);
        L.push_back(l);
    }
 
    void addLine(line l) {
        while (L.size() >= 2 && l.intersect(L[L.size() - 2]) <= x.back()) {
            x.pop_back();
            L.pop_back();
        }
        x.push_back(l.intersect(L.back()));
        L.push_back(l);
    }
 
    int query(int qx) {
        int id = upper_bound(x.begin(), x.end(), qx) - x.begin();
        --id;
        return L[id](qx);
    }
};
```

### 2.李超线段树添加直线.

```c++
#define lson t[x].ls
#define rson t[x].rs
struct lcs{ //类似动态开店的方法。
	int ls,rs;
	ll k,b;
	lcs(){}
	lcs(ll K,ll B){ls=rs=0,k=K,b=B;}
    ll operator () (int x) {
        return k * x + b;
    }
}t[N<<2];
int tot=1;
void add(int x,ll l,ll r,lcs now){
	if(x==0) return;
	ll tk=t[x].k,tb=t[x].b;
	ll mid=(l+r)>>1;
	if(now(l)>=t[x](l) && now(r)>=t[x](r)){
		t[x].k=now.k; t[x].b=now.b;
		return;
	}
	else if(now(l)<t[x](l) && now(r)<t[x](r)) return;
	else{
		if(!lson) lson=++tot,t[tot]=lcs(tk,tb);
		else add(t[x].ls,l,mid,{tk,tb});

		if(!rson) rson=++tot,t[tot]=lcs(tk,tb);
		else add(t[x].rs,mid+1,r,{tk,tb});
		t[x].k=now.k,t[x].b=now.b;
	} 
}
ll query(int x,ll l,ll r,ll p){
	if(x==0) return -1e18;
	ll mid=(l+r)>>1;
	ll ret=t[x](p);
	if(p<=mid) ret=max(ret,query(t[x].ls,l,mid,p));
	else ret=max(ret,query(t[x].rs,mid+1,r,p));
	return ret;
}

ll a[N],b[N];
signed main(){IOS
    ll n,m;cin>>n>>m;
    FOR(i,1,n)cin>>b[i];
    FOR(i,1,m)cin>>a[i];
    sort(b+1,b+1+n,greater<ll>());
    FOR(i,1,n)add(1,-1,1e9,{i,i*b[i]});
    FOR(i,1,m){
        cout<<query(1,-1,1e9,a[i])<<' ';
    }
    cout<<endl;
    return 0;
}
```

### 3.李超线段树添加线段.

```c++
// https://www.luogu.com.cn/problem/P4097
// 板子
1.在平面上加入一条线段。记第 i 条被插入的线段的标号为 i。
2.给定一个数 k，询问与直线 x = k 相交的线段中，交点纵坐标最大的线段的编号。
#define ls rt<<1
#define rs rt<<1|1
const int mod1=39989;
const int mod2=1e9;
const double eps=1e-10;
struct line {
    double k, b;
    ll L,R;
    //line() {}
    //line(int k, int b) : k(k), b(b) {} 
    double operator () (int x) {
        if(L<=x&&x<=R)return k * x + b;
        else return -1e9;
    }
}L[N];
ll cnt;
void add(ll x0,ll y0,ll x1,ll y1){ //按照给的2个点添加线段。直线的话就没有L和R2个端点的限制吧
    cnt++;
    if(x0==x1)L[cnt]={0.0,(double)max(y0,y1),x0,x0};
    else {
        double k=1.0*(1.0*y1-y0)/(1.0*x1-x0);
        double b=1.0*(1.0*y1-k*x1);
        L[cnt]={k,b,min(x0,x1),max(x0,x1)};
    }
}
struct tree{
    ll seg[N<<2];
    db Max(db a,db b){//本题y相同取x最小的，所以新搞个max.
        if(a.first-b.first>eps)return a;
        else if(b.first-a.first>eps)return b;
        else return a.second>b.second?a:b;
    }
    void update(ll rt,ll l,ll r,ll ql,ll qr,ll u){
        ll &v = seg[rt];ll mid=l+r>>1;
        if(ql<=l&&r<=qr){//没有直接更新 
            if(!v){v=u;return;}//如果这条直线在mid最大，就覆盖这条区间，然后swap(u,v)，用新u调整被覆盖的区间。
            if(L[u](mid)-L[v](mid)>eps)swap(u,v);
            if(L[u](l)-L[v](l)>eps||L[u](l)==L[v](l)&&u<v)update(ls,l,mid,ql,qr,u);
            if(L[u](r)-L[v](r)>eps||L[u](r)==L[v](r)&&u<v)update(rs,mid+1,r,ql,qr,u);
            return ;
        }
        if(ql<=mid)update(ls,l,mid,ql,qr,u);
        if(mid<qr)update(rs,mid+1,r,ql,qr,u);
    }
    auto query(ll rt,ll l,ll r,ll k){
        db res,a,b;ll &u=seg[rt];
        if(u)res={L[u](k),-u};
        // 有时候 u为0的时候可以直接返回，具体看情况 例如添加的是直线，没有边界的时候。
        if(l==r)return res;
        ll mid=l+r>>1;
        if(k<=mid)res=Max(res,query(ls,l,mid,k));
        else res=Max(res,query(rs,mid+1,r,k));
        return res;
    }
}root;

signed main(){IOS
    ll q,lastans=0;cin>>q;
    while(q--){
        ll op,x0,y0,x1,y1,k;cin>>op;
        if(!op){
            cin>>k;
            k=(k+lastans-1)%mod1+1;
            cout<<(lastans=-root.query(1,1,mod1,k).second)<<endl;
        }else {
            cin>>x0>>y0>>x1>>y1;
            x0=(x0+lastans-1)%mod1+1;x1=(x1+lastans-1)%mod1+1;
            y0=(y0+lastans-1)%mod2+1;y1=(y1+lastans-1)%mod2+1;
            add(x0,y0,x1,y1);
            root.update(1,1,mod1,min(x0,x1),max(x0,x1),cnt);
        }
    }
    return 0;
}
```



## 杂

### 1.置换环.

```c++
//求一个数组从乱序变为顺序至少需要交换多少次
signed main(){IOS
	ll n;cin>>n;
	FOR(i,1,n){
		cin>>a[i];
		b[i]=a[i];
	}
//	FOR(i,1,n)cout<<a[i]<<' ';
//	cout<<endl;
	unordered_map<ll,ll>id;
	sort(b+1,b+1+n);
	ll res=0;
	FOR(i,1,n)id[b[i]]=i;
	ll ans=0;
	FOR(i,1,n){
		if(!vis[i]){
			ll nxt=i;
			while(!vis[nxt]){
				vis[nxt]=1;
				nxt=id[a[nxt]];
			}
			res++;
		}
	}c
	cout<<n-res<<endl;
```

### 2.umap技巧

```c++
unordered_map<int, int> mp;
mp.reserve(1024);
mp.max_load_factor(0.25);

struct custom_hash
{
    static uint64_t splitmix64(uint64_t x)
    {
        x ^= x << 13;
        x ^= x >> 7;
        x ^= x << 17;
        return x;
    }
    size_t operator()(uint64_t x) const
    {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); // 时间戳
        return splitmix64(x + FIXED_RANDOM);
    }
};
unordered_map<int, int, custom_hash> fac;
```

### 3.快读高精度取模

```c++
const int MOD = 19260817;//MOD是题解中的"p"
inline int getint()
{
    int res = 0, ch = getchar();
    while(!isdigit(ch) and ch != EOF)
        ch = getchar();
    while(isdigit(ch))
    {
        res = (res << 3) + (res << 1) + (ch - '0');
        res %= MOD;//直接对MOD取余
        ch = getchar();
    }
    return res;
}
//https://www.luogu.com.cn/problem/solution/P2613
```



### 4.最小表示法

```c++
string get_min(string s){// 得到一个字符串所有循环中字典序最小的
    ll n=s.size();
    for(int i=0;i<n;i++)s.push_back(s[i]);
    int i=0,j=1,k;
    while(j<n){
        k=0;
        while(k<n&&s[i+k]==s[j+k])k++;
        if(s[i+k]>s[j+k])i+=k+1;
        else j+=k+1;
        if(i==j)j++;
        if(i>j)swap(i,j);
    }
    string res="";
    for(int j=i;j<=i+n-1;j++)res+=s[j];
    return res;
}

signed main(){IOS
    string s,t;cin>>s>>t;
    if(get_min(s)==get_min(t))cout<<"Yes"<<endl;//可以用来判断2个字符串是否循环同构
    else cout<<"No"<<endl;
    return 0;
}
```

### 5.一些小技巧

```c++
#define lbit(a) (__builtin_ffsll(a)) //获得最低位1的位置
#define ubit(a) (64-__builtin_clzll(a)) //获得最高的1的位置
#define popcount(a) __builtin_popcountll(a)//返回二进制1的个数

adjacent_difference(a, a + n, a);
// 返回相邻元素的差值 (a[1],a[2]-a[1].....)


// 不定长度bitset
//https://codeforces.com/contest/1856/problem/E2 例题
template <int len> 
ll cal(int u){
    if(len <= (needlen))return cal<min(N, len<<1)>(u); //len和N都是const 如果len不够就倍长开
    bitset<len>dp;//定长bitset

    return ans;
}
```

### 6.int128读入输出

```c++
typedef __int128_t ll;
inline __int128 read(){
    __int128 x = 0, f = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){
        if(ch == '-')
            f = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9'){
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
 
inline void print(__int128 x){
    if(x < 0){
        putchar('-');
        x = -x;
    }
    if(x > 9)
        print(x / 10);
    putchar(x % 10 + '0');
}
```



# 一些式子：

### 卡特兰数：

$1.H_{n}=\left(\begin{array}{c}
2 n \\
n
\end{array}\right)-\left(\begin{array}{c}
2 n \\
n-1
\end{array}\right)$

2.$H_{n}=\frac{1}{n+1}\left(\begin{array}{c}
2 n \\
n
\end{array}\right)$

3.$H_n=\frac{4 n-2}{n+1} H_{n-1}$

### 生成函数:

1. $\sum_{i=0}^n x^{k i}=\frac{1-x^{k n+k}}{1-x^k}$
2. $\sum_{i=0}^n\left(\begin{array}{c}n \\ i\end{array}\right) p^i x^i=(1+p x)^n$
3. $\sum_{i \geq 0} x^{k i}=\frac{1}{1-x^k}$
4. $\sum_{i \geq 0} p^i x^i=\frac{1}{1-p x}$
5. $\sum_{i \geq 1} x^i=\frac{x}{1-x}$
6. $\sum_{i \geq 0}(i+1) x^i=\frac{1}{(1-x)^2}$
7. $\sum_{i \geq 0}\left(\begin{array}{c}n+i \\ i\end{array}\right) x^i=\frac{1}{(1-x)^{n+1}}$
8. 斐波那契数列的封闭式：$ \frac{x}{1-x-x^2}=\sum_{n\ge 0}x^n \frac{1}{\sqrt{5}}\left( \left(\frac{1+\sqrt{5}}{2}\right)^n-\left(\frac{1-\sqrt{5}}{2}\right)^n \right) $

![image-20230525104646381](C:\Users\leaf_maple\AppData\Roaming\Typora\typora-user-images\image-20230525104646381.png)





# 球盒问题:

0.$n$个**无标号**的球放到$k$个**无标号**的盒子中，盒子**允许为空**

```cpp
int b0(int n, int k)
{
    if(n == 0)
        return 1;
    if(k == 0)
        return 0;
    if(n < k)
        return b0(n, n);
    else 
        return b0(n - k, k) + b0(n, k - 1);
}
```

$1.n$个**无标号**的球放到$k$个**无标号**的盒子中，盒子**不允许为空**

```cpp
int b1(int n, int k)
{
    if(n < k)
        return 0;
    else 
        return b0(n - k, k);
}
```

2.$n$个**无标号**的球放到$k$个**有标号**的盒子中，盒子**允许为空**。
本质：$x_1+x_2+...+x_k=n$的非负整数解的组数。

```cpp
const int N = 1005, md = 1e9 + 7;
int b2(int n, int k)
{
    return c[n + k - 1][k - 1];
}
```

3.$n$个**无标号**的球放到$k$个**有标号**的盒子中，盒子不**允许为空**。
本质：$x_1+x_2+...+x_k=n$的正整数解的组数。

```cpp
const int N = 1005, md = 1e9 + 7;

int b3(int n, int k)
{
    return c[n - 1][k - 1];
}
```

4.$n$个**有 标号**的球放到$k$个**无标号**的盒子中，盒子**允许为空**

```cpp
LL S[N][K];
void initS2()
{//预处理斯特林数
    S[0][0] = 1;
    for(int i = 1; i < N; i ++ )
        for(int j = 1; j < K; j ++)
            S[i][j] = (S[i - 1][j - 1] + S[i - 1][j] * j % md) % md;
    //s[i][j] = (s[i - 1][j - 1] + (ll)(i - 1) * s[i - 1][j] % mod) % mod;
}

int b4(int n, int k)
{
    LL res = 0;
    for(int i = 0; i <= k - 1; i ++)
        res = (res + S[n][k - i]) % md;
    return res;
}
```

特别地，当$n≤k$时，答案即为贝尔数（Bell数）。箱子是相同的，故不需要考虑空出来的是哪些箱子。即$b(n,k)=B_n$

```cpp
const int N = 2000 + 5;
int bell[N][N];

void initBell(int n) {
  bell[1][1] = 1;
  for (int i = 2; i <= n; i++) {
    bell[i][1] = bell[i - 1][i - 1];
    for (int j = 2; j <= i; j++)
      bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1];
  }
}
```

5.$n$个**有标号**的球放到$k$个**无标号**的盒子中，盒子**不允许为空**

```cpp
LL S[N][N];
void initS2()
{//预处理斯特林数
    S[0][0] = 1;
    int R = N - 5;
    for(int i = 1; i <= R; i ++ )
        for(int j = 1; j <= R; j ++)
            S[i][j] = (S[i - 1][j - 1] + S[i - 1][j] * j % md) % md;
}

int b5(int n, int k)
{
    return S[n][k];
}
```

6.$n$个**有标号**的球放到$k$个**有标号**的盒子中，盒子**允许为空**

```cpp
int b6(int n, int k)
{
    return qpow(k, n);
}
```

7.$n$个**有标号**的球放到$k$个**有标号**的盒子中，盒子**不允许为空**

```cpp
LL S[N][N], fac[N];
void init()
{//预处理斯特林数
    S[0][0] = 1, fac[0] = 1;
    int R = N - 5;
    for(int i = 1; i <= R; i ++ )
        for(int j = 1; j <= R; j ++)
            S[i][j] = (S[i - 1][j - 1] + S[i - 1][j] * j % md) % md;
    for(int i = 1; i <= R; i ++ )
        fac[i] = fac[i - 1] * i % md;
}

int b7(int n, int k)
{
    return S[n][k] * fac[k];
}
```

A.$n$个**无标号**的球放到$k$个**无标号**的盒子中，盒子**不允许为空**。每个盒子里**至少**有$t$个球。

$dp[n,k,t]=sum_{i=t}^{n} dp[n-i][k-1][i]$

```cpp
LL dp[N][N][N];
LL dfs(int n, int k, int t)
{
    if(n < k * t)
        return 0;
    if(k == 0)
        return dp[n][k][t] = 0;
    if(k == 1)
        return dp[n][k][t] = 1;
    if(~dp[n][k][t])
        return dp[n][k][t];
    dp[n][k][t] = 0;
    for(int i = t; i <= n; i ++ )
    {
        if(k * i > n)
            break;
        dp[n][k][t] += dfs(n - i, k - 1, i);
        dp[n][k][t] %= md;
    }
    return dp[n][k][t];
}

int main()
{
    memset(dp, -1, sizeof dp);
    int n, k, t;
    cin >> n >> k >> t;
    cout << dfs(n, k, t);
}
```

B.$n$个**无标号**的球放到$k$个**有标号**的盒子中，盒子**允许为空**。$a_1,a_2...a_k$是给定的非负整数的数组，要求第$i$个盒子中至少含有$a_i$个球。
本质：$x_1+x_2+...+x_k=n$且$x_i>a_i$的非负整数解的组数。

![image-20230525110701666](C:\Users\leaf_maple\AppData\Roaming\Typora\typora-user-images\image-20230525110701666.png)



C.$n$个**无标号**的球放到$k$个**有标号**的盒子中，盒子**允许为空**。每个盒子里**至多**$t$个球

![image-20230525110748509](C:\Users\leaf_maple\AppData\Roaming\Typora\typora-user-images\image-20230525110748509.png)

D.$n$个**有标号**的球放到$k$个**有标号**的盒子中，盒子**不允许为空**。每个盒子里**至多**$t$个球

[题目](http://acm.hdu.edu.cn/contest/problem?cid=1098&pid=1005)



# 莫比乌斯反演

形式一：如果有 $f(n)=\sum_{d \mid n} g(d)$ ，那么有 $g(n)=\sum_{d \mid n} \mu(d) f\left(\frac{n}{d}\right)$ 。

形式二：如果有 $f(n)=\sum_{n \mid d} g(d)$ ，那么有 $g(n)=\sum_{n \mid d} \mu\left(\frac{d}{n}\right) f(d)$ 。

经典柿子:

1.$\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=k]$ $(1\le T,n,m,k\le5\times10^4)$  $=\sum_{i=1}^{n/k} \mu(i) \lfloor {\frac{n}{ik}}\rfloor \lfloor {\frac{m}{ik}}\rfloor$  

2.



